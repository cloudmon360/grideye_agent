/*
  Copyright (C) 2015-2018 Olof Hagsand

  This file is part of GRIDEYE.

  GRIDEYE is free software; you can redistribute it and/or modify
  it under the terms of the GNU General Public License as published by
  the Free Software Foundation; either version 3 of the License, or
  (at your option) any later version.

  GRIDEYE is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  GNU General Public License for more details.

  You should have received a copy of the GNU General Public License
  along with GRIDEYE; see the file LICENSE.  If not, see
  <http://www.gnu.org/licenses/>.
*/

#define _GNU_SOURCE /* This is to enable O_DIRECT */
#if defined(__i386__)
#define _FILE_OFFSET_BITS 64
#endif

#include <stdio.h>
#include <stdlib.h>
#include <inttypes.h>
#include <string.h>
#include <signal.h>
#include <sys/param.h>
#include <sys/socket.h>
#include <sys/uio.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <netdb.h>
#include <unistd.h>
#include <time.h>
#include <assert.h>
#include <dirent.h>
#include <fcntl.h>
#include <dlfcn.h>
#include <errno.h>
#include <sys/time.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <sys/ioctl.h>
#include <syslog.h>
#include <net/if.h>
#include <math.h>
#include <curl/curl.h>
#include <sys/utsname.h>

#ifdef HAVE_LINUX_SOCKIOS_H
#include <linux/sockios.h> /* Dont remove: SIOCGIFADDR will be undefined below */
#elif defined(HAVE_SYS_SOCKIO_H)
#include <sys/sockio.h> /* Dont remove: SIOCGIFADDR will be undefined below */
#endif

/* For Python plugin support */
#include <Python.h>

#include <cligen/cligen.h>     /* cbuf */
#include <clixon/clixon.h>     /* xml, xpath, log, err */

#include "grideye_agent.h"     /* lib */
#include "grideye_plugin.h" /* plugin C API */

/*
 * Global variables generated by Makefile
 */
extern const char GRIDEYE_BUILDSTR[];
extern const char GRIDEYE_VERSION[];

/* Protocol agent version. Bundle with plugin API version
 * I.e. one agent version supports one plugin version
 * But one controller must support multiple agent versions
 *
 * Version 2:
 *   New more capable test and plugin protocol
 * Version 3:
 *   Send callhome as restconf clixon RPC instead of just HTTP
 *   HTTP initiated from agent as control protocol option
 */
#define GRIDEYE_AGENT_VERSION 3

/* Set this to a file (prefix) and this will dump incoming binary messages */
//#define DUMPMSGFILE "grideyedump"

#define DISKIO_DIR        "/var/tmp"  /* in current dir */
#define DISKIO_LARGEFILE  "GRIDEYE_LARGEFILE" /* To use for random read ops */
#define DISKIO_WRITEFILE  "GRIDEYE_WRITEFILE" /* To use for trunc writing */

#define GRIDEYE_AGENT_PIDFILE "/var/run/grideye_agent.pidfile"

/* This timeout may interfer with network timeout. It should be well above
 * interval setting (eg yang sender->round->interval
 * but may also trigger if the probe is out of reach for a period of time
 * So: either no traffic reaching the probe, or "wrong" traffic reaching,
 * Wrong being for example a new sender (the old is dead).
 */
#define CALLHOME_DEFAULT  20 /* seconds */

/* CURL post timeout - wait for remote end to answer in seconds */
#define CURL_TIMEOUT_DEFAULT 60 

/* Wireless file to read status from */
#define PROC_NET_WIRELESS "/proc/net/wireless"

/* Run with american fuzzy lop http://lcamtuf.coredump.cx/afl 
 * Only runs with -p http and replaces curl with stdin/stdout
 */
#undef FUZZ

/* By default, this is where grideye_agent looks for plugins
 * This is normally set in configure/Makefile as $exec_prefix/lib/grideye
 * eg /usr/local/lib/grideye.
 */
#ifndef PLUGINDIR
#define PLUGINDIR "/usr/local/lib/grideye"
#endif

#define GRIDEYE_PLUGIN_PYTHON 0x50595448

#ifdef FUZZ
#define GRIDEYE_AGENT_OPTS "hDFvtqe:f:i:a:l:W:u:I:N:w:P:zk:sT:Z"
#else
#define GRIDEYE_AGENT_OPTS "hDFvtqe:f:i:a:l:W:u:I:N:w:P:zk:sT:"
#endif

/*
 * Local types
 */
struct sender {
    struct sender  *s_next;    /* linked list */
    void           *s_sname;   /* socket name, eg sockaddr */
    socklen_t       s_snamelen;
    char           *s_name;    /* name given by sender */
    uint32_t        s_seq;
    cxobj          *s_xml;     /* XML control tree with config info received in
			        * most recdetn callhome reply */
};

/*
 * Types buffer for curl
 */
struct curlbuf{
    size_t b_len;
    char  *b_buf;
};

/* Info of a plugin. Make a vector of these for all plugins */
struct plugin{
    void                         *p_handle;
    int                           p_version;
    char                         *p_filename; /* Actual filename */
    char                         *p_name;     /* Name corresponds to yang spec */
    int                           p_disable; /* something failed */
    struct grideye_plugin_api *p_api;
};

/*
 * Local variables
 */
static struct sender *s_list = NULL;
/* XXX: should be moved as doexit code is moved */
static char hostname[128] = {0,};/* name of this host, -N or gethostname */
static int  pkts = 0;		 /* packets received counter */
static int  errpkts = 0;	 /* dropped packets received counter */
struct timeval firstpkt, lastpkt;
static int     quiet = 0;
static struct plugin *plugins = NULL;
static char    *pidfile = GRIDEYE_AGENT_PIDFILE;
static char *plugin_dir = NULL;
static int ssl_verifypeer = 0;

#ifdef FUZZ
/* AFL fuzzing simulation */
static int fuzz = 0;
#endif

/*
 *! Return number of plugins in plugins vector. This is one less than vectorlen
 */
static int
plugins_len(struct plugin *plugins)
{
    int            i=0;
    struct plugin *p;

    i = 0;
    for (p = plugins; p->p_api!=NULL; p++, i++);
    return i;
}

/*! helper function */
static struct plugin *
plugin_find(char *name)
{
    struct plugin *p;

    for (p = plugins; p&&p->p_api!=NULL; p++)
	if (strcmp(p->p_name, name) == 0)
	    return p;

    return NULL;
}

/*
 *! Convert value of a Python object to a char array
 */
static char
*grideye_pyobj_to_char(PyObject *pyobj)
{
	char *cstr;
	PyObject *tmpstr;

	// Make sure we have a string object
	if (!strcmp((char *)Py_TYPE(pyobj), "str"))
	    goto fail;

	// In Python 3 all strings are unicode
	if ((tmpstr = PyUnicode_AsEncodedString(pyobj, "utf-8", "")) == NULL)
	    goto fail;

	if ((cstr = PyBytes_AS_STRING(tmpstr)) == NULL)
	    goto fail;

	return cstr;

fail:
	return NULL;
}

/*
 *! Convert Python object to integer
 */
static unsigned long
grideye_pyobj_to_long(PyObject *pyobj)
{
	unsigned long ret;
	static unsigned long long_max = 0xFFFFFFFF;

	// Make sure we have an integer
	ret = PyLong_AsUnsignedLong(pyobj);

	if (ret == -1 || ret > long_max)
		goto fail;

	return ret;

fail:
	return -1;
}

/*
 *!
 */
static char
*grideye_call_method(char *name,
		     char *method,
		     char *argstr)
{
    PyObject *pymethod;
    PyObject *pyargs;
    PyObject *pyvalue;
    PyObject *pyretval;
    PyObject *pyname;
    PyObject *pymodule;

    char     *outstr;
    char     *syscmd = NULL;
    char     *modulename = NULL;

    int      modulelen = 0;
    int      syscmdlen = 0;

    if (argstr == NULL)
	    argstr = "";

    if ((modulelen = snprintf(NULL, 0, "grideye_%s", name)) <= 0)
	goto fail;

    if ((syscmdlen = snprintf(NULL,
			      0,
			      "sys.path.append(\"%s\")",
			      plugin_dir)) <= 0)
	goto fail;

    if ((modulename = calloc(modulelen + 1, sizeof(char))) == NULL) {
	clicon_err(OE_UNIX, errno, "calloc");
	goto fail;
    }

    if ((syscmd = calloc(syscmdlen + 1, sizeof(char))) == NULL) {
	clicon_err(OE_UNIX, errno, "calloc");
	goto fail;
    }

    if (snprintf(modulename, modulelen + 1, "grideye_%s", name) <= 0)
	goto fail;

    if (snprintf(syscmd, syscmdlen + 1,
		 "sys.path.append(\"%s\")",
		 plugin_dir) <= 0)
	goto fail;

    Py_Initialize();

    PyRun_SimpleString("import sys");
    PyRun_SimpleString(syscmd);

    if (syscmd)
	free(syscmd);

    pyname = PyUnicode_DecodeFSDefault(modulename);
    pymodule = PyImport_Import(pyname);

    Py_DECREF(pyname);

    if (pymodule == NULL) {
	clicon_log(LOG_ERR, "Failed to load Python module %s method %s", modulename, method);
	goto fail;
    }

    if (modulename)
	free(modulename);

    pymethod = PyObject_GetAttrString(pymodule, method);
    if (!pymethod || !PyCallable_Check(pymethod)) {
	clicon_log(LOG_ERR, "Method %s is not callable", PLUGIN_INIT_FN);
	goto fail;
    }

    Py_DECREF(pymodule);

    pyargs = PyTuple_New(1);
    pyvalue = PyBytes_FromString(argstr);

    PyTuple_SetItem(pyargs, 0, pyvalue);

    Py_DECREF(pyvalue);

    if ((pyretval = PyObject_CallObject(pymethod, pyargs)) == NULL) {
	goto fail;
    }

    Py_DECREF(pyargs);
    Py_DECREF(pymethod);

    if (PyList_Check(pyretval) != 1 || PyList_Size(pyretval) != 1) {
	goto fail;
    }

    outstr = strdup(grideye_pyobj_to_char(PyList_GetItem(pyretval, 0)));

    Py_DECREF(pyretval);

    // Py_Finalize();

    return outstr;

fail:
    Py_Finalize();

    return NULL;
}

/*
 * Load a Python plugin.
 */
static int
grideye_plugin_load_py(void *handle,
		       char *name,
		       char *filename,
		       struct plugin *plugins[])
{
    struct grideye_plugin_api *api = NULL;
    int                       len = 0;
    int                       retval = 0;
    char                      *syscmd = NULL;
    char                      *modulename = NULL;
    int                       syscmdlen = 0;
    int                       modulelen = 0;

    // Python objects
    PyObject                  *pyname;
    PyObject                  *pymodule;
    PyObject                  *pyvalue;
    PyObject                  *pyfunc;
    PyObject                  *pyretval;
    PyObject                  *pyargs;

    int                       gp_version = 0;
    int                       gp_magic = 0;

    modulename = strdup(name);
    modulelen = strlen(modulename);
    modulename[modulelen - 3] = '\0';

    if ((syscmdlen = snprintf(NULL,
			      0,
			      "sys.path.append(\"%s\")",
			      plugin_dir)) <= 0)
	goto fail;

    if ((syscmd = calloc(syscmdlen + 1, sizeof(char))) == NULL) {
	clicon_err(OE_UNIX, errno, "calloc");
	goto fail;
    }

    if ((snprintf(syscmd,
		  syscmdlen + 1,
		  "sys.path.append(\"%s\")",
		  plugin_dir)) <= 0) {
	goto fail;
    }


    Py_Initialize();
    PyRun_SimpleString("import sys");
    PyRun_SimpleString(syscmd);

    if (syscmd)
	free(syscmd);

    pyname = PyUnicode_DecodeFSDefault(modulename);

    if ((pymodule = PyImport_Import(pyname)) == NULL) {
	clicon_log(LOG_ERR, "Failed to load Python module %s method %s", modulename, PLUGIN_INIT_FN);
	goto fail;
    }

    if (modulename)
	free(modulename);

    Py_DECREF(pyname);

    pyfunc = PyObject_GetAttrString(pymodule, PLUGIN_INIT_FN);
    if (!pyfunc || !PyCallable_Check(pyfunc)) {
		clicon_log(LOG_ERR,
			   "Function %s is not callable",
			   PLUGIN_INIT_FN);
		goto fail;
    }

    Py_DECREF(pymodule);

    pyargs = PyTuple_New(1);
    pyvalue = PyLong_FromLong(GRIDEYE_PLUGIN_VERSION);

    PyTuple_SetItem(pyargs, 0, pyvalue);

    Py_DECREF(pyvalue);

    if ((pyretval = PyObject_CallObject(pyfunc, pyargs)) == NULL)
		goto fail;

    Py_DECREF(pyargs);

    if (PyList_Check(pyretval) != 1 || PyList_Size(pyretval) != 9) {
		goto fail;
    }

    if ((gp_version = grideye_pyobj_to_long(PyList_GetItem(pyretval, 0)))
	!= GRIDEYE_PLUGIN_VERSION) {
	    clicon_log(LOG_NOTICE,
		       "grideye_agent: Disabling %s, wrong version",
		       gp_version);
	    goto fail;
    }

    if ((api = calloc(1, sizeof(struct grideye_plugin_api))) == NULL)
	clicon_err(OE_UNIX, errno, "calloc");

    if ((gp_magic = grideye_pyobj_to_long(PyList_GetItem(pyretval, 1)))
	!= GRIDEYE_PLUGIN_MAGIC) {
	    clicon_log(LOG_NOTICE,
		       "grideye_agent: Disabling %s, wrong magic",
		       gp_magic);
	    goto fail;
    }

    api->gp_version = gp_version;
    api->gp_name = grideye_pyobj_to_char(PyList_GetItem(pyretval, 2));
    api->gp_input_format = grideye_pyobj_to_char(PyList_GetItem(pyretval, 3));
    api->gp_output_format = grideye_pyobj_to_char(PyList_GetItem(pyretval, 4));
    api->gp_getopt_fn = (grideye_plugin_getopt_t *)grideye_pyobj_to_char(PyList_GetItem(pyretval, 5));
    api->gp_setopt_fn = (grideye_plugin_setopt_t *)grideye_pyobj_to_char(PyList_GetItem(pyretval, 6));
    api->gp_test_fn = (grideye_plugin_test_t *)grideye_pyobj_to_char(PyList_GetItem(pyretval, 7));
    api->gp_exit_fn = (grideye_plugin_exit_t *)grideye_pyobj_to_char(PyList_GetItem(pyretval, 8));

    /* Make it possible to distinguish between regular plugins and py-plugins */
    api->gp_magic = GRIDEYE_PLUGIN_PYTHON;

    len = plugins_len(*plugins);
    if ((*plugins = realloc(*plugins, (len+2)*sizeof(struct plugin))) == NULL){
	clicon_err(OE_UNIX, errno, "grideye_agent: realloc failed");
	goto fail;
    }

    memcpy(&(*plugins)[len+1], &(*plugins)[len], sizeof(struct plugin));
    (*plugins)[len].p_handle = handle;

    if (((*plugins)[len].p_filename = strdup(name)) == NULL){
	clicon_err(OE_UNIX, errno, "grideye_agent: strdup failed");
	goto fail;
    }

    /* Plugin name should be read for plugin itself, but use filename - ext */
    if (((*plugins)[len].p_name = strdup(api->gp_name)) == NULL){
	clicon_err(OE_UNIX, errno, "grideye_agent: strdup failed");
	goto fail;
    }

    (*plugins)[len].p_api = api;

    Py_Finalize();

    retval = 1;

 done:
    return retval;

 fail:
    retval = 1;
    goto done;
}

/*! Load a specific plugin, call its init function and add it to plugins list
 * If init function fails (not found, wrong version, etc) print a log and dont
 * add it.
 */
static int
grideye_plugin_load_so(void       *handle,
		    char          *name,
		    char          *filename,
		    struct plugin *plugins[]
		    )
{
    int                           retval = -1;
    char                          *dlerrcode;
    grideye_plugin_init_t         *initfun;
    struct grideye_plugin_api     *api = NULL;
    int                           len;

    /* Try v2 */
    initfun = dlsym(handle, PLUGIN_INIT_FN);
    if ((dlerrcode = (char*)dlerror()) != NULL) {
	clicon_log(LOG_DEBUG, "grideye_agent: %s Skipping %s", __FUNCTION__, dlerrcode);
	goto fail;
    }
    if ((api = initfun(GRIDEYE_PLUGIN_VERSION)) == NULL) {
	clicon_log(LOG_DEBUG, "grideye_agent: %s: failed when running init function %s: %s",
		   filename, PLUGIN_INIT_FN, errno?strerror(errno):"");
	clicon_log(LOG_NOTICE, "grideye_agent: Plugin: Disabling %s (could not start plugin)", name);
	goto fail;
    }
    if (api->gp_version != GRIDEYE_PLUGIN_VERSION){
	clicon_log(LOG_WARNING, "grideye_agent: Plugin: %s unexpected version number: %d",
		   name, api->gp_version);
	goto fail;
    }
    if (api->gp_magic != GRIDEYE_PLUGIN_MAGIC){
	clicon_log(LOG_WARNING, "grideye_agent: Plugin: %s wrong plugin magic number: %x",
		   name, api->gp_magic);
	goto fail;
    }
    len = plugins_len(*plugins);
    if ((*plugins = realloc(*plugins, (len+2)*sizeof(struct plugin))) == NULL){
	clicon_err(OE_UNIX, errno, "grideye_agent: realloc failed");
	goto done;
    }

    memcpy(&(*plugins)[len+1], &(*plugins)[len], sizeof(struct plugin));
    (*plugins)[len].p_handle = handle;

    if (((*plugins)[len].p_filename = strdup(name)) == NULL){
	clicon_err(OE_UNIX, errno, "grideye_agent: strdup failed");
	goto done;
    }

    /* Plugin name should be read for plugin itself, but use filename - ext */
    if (((*plugins)[len].p_name = strdup(api->gp_name)) == NULL){
	clicon_err(OE_UNIX, errno, "grideye_agent: strdup failed");
	goto done;
    }

    (*plugins)[len].p_api = api;

    clicon_log(LOG_NOTICE, "grideye_agent: Plugin: Loading %s", name);
    clicon_log(LOG_DEBUG, "grideye_agent: Plugin: Loading %s from %s", name, filename);

    retval = 0;
 done:
    if (retval < 0)
	dlclose(handle);
    return retval;
 fail: /* plugin load failed, continue */
    retval = 0;
    goto done;
}

/*! Load grideye agent plugins from directory, call init and return handles in vector
 * @param[in]  dir      name of directory where grideye .so plugins reside
 * @param[out] plugins  Null-terminated vector of plugin handles.
 */
static int
plugin_load_dir(char          *dir,
		struct plugin *plugins[])
{
    int            retval = -1;
    DIR           *dirp = NULL;
    struct dirent  dent;
    struct dirent *dresp;
    void          *handle = NULL;
    int            res;
    char          *name;
    int            off_so;
    int            off_py;
    char          *filename = NULL;
    int            len;

    if ((dirp = opendir(dir)) == NULL) {
	clicon_err(OE_PLUGIN, errno, "opendir(%s)", dir);
	if (errno == ENOENT)
	    fprintf(stderr, "No grideye_agent test .so plugins found in %s\n",
		    dir);
	goto done;
    }
    /*
     * dirent->d_name is name of directory entry, if dresp is NULL the iteration
     * is done
     */
   for (res = readdir_r(dirp, &dent, &dresp);
	dresp;
	res = readdir_r (dirp, &dent, &dresp)){
       if (res != 0) {
	   clicon_err(OE_UNIX, errno, "readdir");
	   goto done;
       }
       /* match .so */
       name = dent.d_name;
       off_so = strlen(name)-5;
       off_py = strlen(name) - 3;

       if ((off_so <= 0 || strcmp(".so.1", name + off_so) != 0) && (off_py <= 0 || strcmp(".py", name + off_py) != 0))
	   continue;
       len = strlen(dir)+1+strlen(name)+1;
       if ((filename = malloc(len)) == NULL){
	   clicon_err(OE_UNIX, errno, "malloc");
	   goto done;
       }

       snprintf(filename, len, "%s/%s", dir, name);

       if (strcmp(".so.1", name + off_so) == 0) {
	   dlerror();    /* Clear any existing error */
	   if ((handle = dlopen(filename, RTLD_NOW)) == NULL) {
	       clicon_err(OE_UNIX, 0, "dlopen: %s", (char*)dlerror());
	       goto done;
	   }

	   if (grideye_plugin_load_so(handle, name, filename, plugins) < 0){
	       free(filename);
	       goto done;
	   }
       } else if (strcmp(".py", name + off_py) == 0) {
	   /* Python plugin */
	   if (grideye_plugin_load_py(handle, name, filename, plugins) < 0) {
	       clicon_log(LOG_NOTICE, "grideye_agent: Plugin: Disabling %s",
			  basename(filename));
	       free(filename);
	       goto done;
	   } else {
	       clicon_log(LOG_NOTICE, "grideye_agent: Plugin: Loading %s",
			  basename(filename));
	   }
       }

       free(filename);
   }
    retval = 0;
 done:
    if (dirp)
	closedir(dirp);
    return retval;
}

#ifdef notyet
static int
plugin_unload (void)
{
    int   retval = -1;

    dlerror();    /* Clear any existing error */
    if (dlclose(plg->p_handle) != 0) {
	clicon_err(OE_PLUGIN, errno, "dlclose");
	goto done;
    }
    retval = 0;
 done:
    return retval;
}
#endif /* notyet */

/*! Get (reply) data from server
 */
static size_t
curl_get_cb(void  *ptr,
	    size_t size,
	    size_t nmemb,
	    void  *userdata)
{
    struct curlbuf *buf = (struct curlbuf *)userdata;
    int len;

    len = size*nmemb;
    if ((buf->b_buf = realloc(buf->b_buf, buf->b_len+len+1)) == NULL)
	return 0;
    memcpy(buf->b_buf+buf->b_len, ptr, len);
    buf->b_len += len;
    buf->b_buf[buf->b_len] = '\0';
    //    fprintf(stderr, "%s: %s\n", __FUNCTION__, buf->b_buf);
    return len;
}

/*! Send a curl POST request
 * @param[in]  url      URL - where to send post request to
 * @param[in]  putdata  Data to post
 * @param[in]  header   If set, send as header, eg "Content-Type: application/yang-data+xml"
 * @param[in]  timeout  Curl post request timeout in seconds
 * @param[out] getdata  Pointer to return data, if given, free with malloc
 * @param[out] remoteip Pointer remote IP address in string format
 * @retval    -2   fatal error
 * @retval    -1   non fatal error. Log error and try again
 * @retval     0   expect set but did not expected return or other non-fatal error
 * @retval     1   ok
 * Note: Code taken from grideye
 * Note: curl_easy_perform blocks
 * Note: New handle is created every time, the handle can be re-used for better TCP performance
 */
static int
url_post(char *url,
	 char *putdata,
	 char *header,
	 char *expect,
	 int   timeout,
	 char **getdata,
	 char **remoteip)
{
    CURL      *curl = NULL;
    char      *err = NULL;
    int        retval = -2;
    cxobj     *xr = NULL; /* reply xml */
    struct curlbuf cb = {0, };
    CURLcode   errcode;
    char      *ip = NULL;
    struct curl_slist *list = NULL;

#ifdef FUZZ
    if (fuzz){
      char *s;
      int   len=10*1024;

      if ((*getdata = malloc(len))== NULL){
	clicon_err(OE_PLUGIN, errno, "malloc");
	goto done;
      }
      fprintf(stderr, "%s\n", putdata);
      /* Help text for manual fuzzing */
      fprintf(stdout, "FUZZ:"); fflush(stdout);
      errno = 0;
      if ((s=fgets(*getdata, len, stdin)) == NULL){
	  if (feof(stdin))
	      exit(0);
	  clicon_err(OE_PLUGIN, errno, "fgets: %d", errno);
	  goto done;
      }
      if (s && strlen(s) && s[0]=='q') /* termination criteria */
	exit(0);
      //      fprintf(stdout, "\nGOT:%s", s); fflush(stdout);
      return 0;
    }
#endif /* FUZZ */
    /* Try it with  curl -X PUT -d '*/
    clicon_debug(1,  "%s:  curl -X POST -d '%s' %s",
	       __FUNCTION__, putdata, url);

    /* Set up curl for doing the communication with the controller */
    if ((curl = curl_easy_init()) == NULL) {
	clicon_err(OE_PLUGIN, errno, "curl_easy_init");
	goto done;
    }
    if ((err = malloc(CURL_ERROR_SIZE)) == NULL) {
	clicon_err(OE_UNIX, errno, "malloc");
	goto done;
    }
    memset(err, 0, CURL_ERROR_SIZE);
    curl_easy_setopt(curl, CURLOPT_URL, url);
    curl_easy_setopt(curl, CURLOPT_ERRORBUFFER, err);
    curl_easy_setopt(curl, CURLOPT_WRITEFUNCTION, curl_get_cb);
    curl_easy_setopt(curl, CURLOPT_WRITEDATA, &cb);
    curl_easy_setopt(curl, CURLOPT_POST, 1);
    curl_easy_setopt(curl, CURLOPT_POSTFIELDS, putdata);
    curl_easy_setopt(curl, CURLOPT_POSTFIELDSIZE, strlen(putdata));
    /* XXX:
     * If you want to connect to a site who isn't using a certificate that is
     * signed by one of the certs in the CA bundle you have, you can skip the
     * verification of the server's certificate. This makes the connection
     * A LOT LESS SECURE.
     */

    if (ssl_verifypeer > 0)
	curl_easy_setopt(curl, CURLOPT_SSL_VERIFYPEER, 0L);
    if (ssl_verifypeer > 1)
	curl_easy_setopt(curl, CURLOPT_SSL_VERIFYHOST, 0L);
    if (debug>1)
	curl_easy_setopt(curl, CURLOPT_VERBOSE, 1);
    if (header){
	list = curl_slist_append(list, header);
	curl_easy_setopt(curl, CURLOPT_HTTPHEADER, list);
    }

    curl_easy_setopt(curl, CURLOPT_TIMEOUT, timeout); /* Curl timeout */

    errcode = curl_easy_perform(curl);
    switch (errcode){
    case CURLE_COULDNT_RESOLVE_HOST:
    case CURLE_OPERATION_TIMEDOUT:
    case CURLE_COULDNT_CONNECT:
	clicon_log(LOG_WARNING, "%s: %s", url, curl_easy_strerror(errcode));
	retval = -1; /* non-fatal */
	goto done;
	break;
    case CURLE_OK:
	clicon_debug(1, "%s: OK", url);
	break;
    default:
	clicon_err(OE_UNIX, 0, "curl_easy_perform: %s %s errcode:%d",
		   curl_easy_strerror(errcode), err, errcode);
    }
    if (remoteip &&
	curl_easy_getinfo(curl, CURLINFO_PRIMARY_IP, &ip) == CURLE_OK)
	if ((*remoteip = strdup(ip)) == NULL){
	    clicon_err(OE_UNIX, errno, "strdup");
	    goto done;
	}

    if (expect){
	if (cb.b_buf == NULL){
	    clicon_err(OE_PLUGIN, 0, "%s: no match", __FUNCTION__);
	    retval = 0;
	    goto done;
	} else {
	    clicon_debug(1,  "%s: reply:%s", __FUNCTION__, cb.b_buf);
	    if (xml_parse_string(cb.b_buf, NULL, &xr) < 0){
		clicon_log(LOG_DEBUG,  "%s: %s", __FUNCTION__, cb.b_buf);
		goto done;
	    }
	    if (xpath_first(xr, expect) == NULL){
		clicon_err(OE_PLUGIN, 0, "%s: no match", __FUNCTION__);
		retval = 0;
		goto done;
	    }
	}
    }
    if (getdata && cb.b_buf){
	*getdata = cb.b_buf;
	clicon_debug(1, "%s: getdata:%s", __FUNCTION__, *getdata);
	cb.b_buf = NULL;
    }
    retval = 1;
  done:
    clicon_debug(1, "%s: retval:%d", __FUNCTION__, retval);
    if (list)
	curl_slist_free_all(list);
    if (err)
	free(err);
    if (xr)
	xml_free(xr);
    if (cb.b_buf)
	free(cb.b_buf);
    if (curl)
	curl_easy_cleanup(curl);   /* cleanup */
    return retval;
}

static int
s_rm(struct sender *s)
{
    struct sender   *c;
    struct sender  **s_prev;

    s_prev = &s_list;
    for (c = *s_prev; c; c = c->s_next){
	if (c == s){
	    if (s->s_sname)
		free(s->s_sname);
	    if (s->s_xml)
		xml_free(s->s_xml);
	    if (s->s_name)
		free(s->s_name);
	    *s_prev = c->s_next;
	    free(s);
	    break;
	}
	s_prev = &c->s_next;
    }
    return 0;
}

static int
echo_application(cxobj         *xt,
		 cbuf          *cb,
		 struct plugin  plugins[])
{
    int                retval = -1;
    uint64_t          *v = NULL;
    int64_t           *vi = NULL;
    int                i;
    int                j;
    struct plugin     *p;
    struct grideye_plugin_api *api;
    char              *pstr;
    int                pret;
    char              *str = NULL;
    cxobj             *x;
    cxobj             *xp;
    cxobj            **xvec = NULL;
    size_t             xlen;
    cxobj            **xpvec = NULL;
    size_t             argc;
    char             **argv = NULL;

    clicon_log(LOG_DEBUG, "grideye_agent: %s", __FUNCTION__);
    /* Invoke plugins */
    if (xpath_vec(xt, "plugin", &xvec, &xlen) < 0)
	goto done;
    /* Loop through plugin calls */
    for (i=0; i<xlen; i++){
	xp = xvec[i];
	if ((x = xpath_first(xp, "name")) == NULL){
	    clicon_log(LOG_ERR, "grideye_agent: %s: <name> expected in plugin",
		       __FUNCTION__);
	    retval = 0; 	    /* sanity check failed, just continue */
	    errpkts++;
	    goto done;
	}

	pstr = xml_body(x);

	/* Find matching plugin */
	if ((p = plugin_find(pstr)) == NULL)
	    continue; /* silently ignore */
	if (p->p_disable)
	    continue; /* silently ignore */
	if ((api = p->p_api) == NULL)
	    continue; /* silently ignore */

	if (api->gp_test_fn != NULL) {
	    if (xpath_vec(xp, "param", &xpvec, &argc) < 0)
		goto done;
	    if (argv != NULL)
		free(argv);
	    if ((argv = calloc(argc+1, sizeof(char*))) == NULL){
		clicon_err(OE_UNIX, errno, "calloc");
		goto done;
	    }
	    for (j=0; j<argc; j++)
		argv[j] = xml_body(xpvec[j]);
	    if (api->gp_magic == GRIDEYE_PLUGIN_PYTHON) {
		if ((str = grideye_call_method(api->gp_name,
					       (char *)api->gp_test_fn,
					       /* XXX */      argc?argv[0]:NULL)) == NULL)
		    continue;
	    } else {
		if ((pret = api->gp_test_fn(argc, argv, &str)) < 0) {
		    clicon_log(LOG_NOTICE, "grideye_agent: Plugin: %s failed: %s",
			       p->p_name, str?str:"");
		    continue;
		}
	    }
	    if (str) {
		if (strcmp(api->gp_output_format, "json")==0){
		    cxobj *xt= NULL;
		    if (json_parse_str(str, &xt) < 0)
			goto done;
		    xml_rootchild(xt,0,&xt);
		    if (xml2json_cbuf(cb, xt, 0) < 0)
			goto done;
		    xml_free(xt);
		}
		else
		    cprintf(cb, "%s", str); /* XML */
		free(str);
		str = NULL;
	    }
	}
    }

    clicon_log(LOG_DEBUG, "grideye_agent: %s return:%s", __FUNCTION__, cbuf_get(cb));
    retval = 1; /* OK */
 done:
    if (argv != NULL)
	free(argv);
    if (xvec)
       free(xvec);
    if (xpvec)
       free(xpvec);
    if (v)
	free(v);
    if (vi)
	free(vi);
    return retval;
}


/*! This is signaling: create agent to send to this agent 
 * Send a CURL POST to controller and register (or change) existing agent.
 * @param[in]  url
 * @param[in]  name
 * @param[in]  id
 * @param[in]  proto
 * @param[in]  myaddr        Address, port of locally bound socket
 * @param[in]  info          Info about this node/agent
 * @param[in]  curl_timeout  Curl post request timeout in seconds
 * @param[in]  xym           yang metrics required for this agent
 * @param[in,out] natstate   0:none 1:enabled 2:addr&port defined 3: connected
 * @see nattraversal_udp
 * XXX: problem with using curl primary_ip in registering server. Eg curl localhost can resolve to
 *      ::1 , 127.0.1.1 or 127.0.0.1 but the server sender can use typically 127.0.0.1
 */
static int
callhome_http(char               *url,
	      char               *name,
	      char               *id,
	      struct sockaddr_in *myaddr,
	      char               *info,
	      int                 curl_timeout,
	      cxobj              *xym,
	      int                *natstate)
{
    int    retval = -1;
    cbuf  *ub = NULL;
    cbuf  *cb = NULL;
    char  *getdata = NULL;
    cxobj *xreply = NULL;
    cxobj *x;
    char  *remoteip = NULL;
    struct plugin *p;
    int    i;
    int    ret;
    char  *err = NULL;

    clicon_debug(1, "%s", __FUNCTION__);
    if ((ub = cbuf_new()) == NULL){ /* URL */
      clicon_err(OE_UNIX, errno, "cbuf_new");
      goto done;
    }
    if ((cb = cbuf_new()) == NULL){ /* data */
      clicon_err(OE_UNIX, errno, "cbuf_new");
      goto done;
    }
    cprintf(cb, "{\"input\":{");
    cprintf(cb, "\"name\":\"%s\",", name);
    cprintf(cb, "\"id\":\"%s\",", id);
    if (myaddr && myaddr->sin_port) /* tcp may have port 0 since agent will connect later */
	cprintf(cb, "\"port\":%hu,", ntohs(myaddr->sin_port));
    cprintf(cb, "\"version\":%u,", GRIDEYE_AGENT_VERSION);
#if 1
    if (xym){
	cbuf *cbtmp;
	char *str;
	if ((cbtmp=cbuf_new()) == NULL)
	    goto done;
	if (xml2json_cbuf_vec(cbtmp, xml_childvec_get(xym),xml_child_nr(xym), 0) < 0)
	    goto done;
	str = cbuf_get(cbtmp);
	str++;
	str[strlen(str)-1] = '\0';
	cprintf(cb, "%s,", str);
	cbuf_free(cbtmp);
    }
#endif
    if (info)
	cprintf(cb, "\"info\":\"%s\",", info);
    cprintf(cb, "\"plugins\":[");
    i = 0;
    for (p = plugins; (p->p_api!=NULL); p++){
	if (p->p_disable)
	    continue;
	if (i++)
	    cprintf(cb, ",");
	cprintf(cb, "\"%s\"", p->p_name);
    }
    cprintf(cb, "],");
    cprintf(cb, "\"proto\":\"%s\"", grideye_proto2str(GRIDEYE_PROTO_HTTP));
    cprintf(cb, "}}");
    cprintf(ub, "%s/restconf/operations/grideye:callhome", url);
    ret = url_post(cbuf_get(ub), cbuf_get(cb), "Content-Type: application/yang-data+json", NULL, curl_timeout,
		   &getdata, &remoteip);
    switch (ret){
    case -2: /* fatal */
	goto done;
    case -1: /* non-fatal */
	*natstate = 0;
	goto ok;
    default:
	break;
    }
    if (getdata == NULL)
	goto done;

    /* xml parse reply: here is where we get the port */
    /* XXX KLUDGE TO SEE IF IT IS XML. ERROR COMES AS HTML 
     * In all cases, go back to callhome mode.
     * If HTML, then we cant use XML parser, since it is not properly formed.
     */
    if (getdata[0] == '<'){
	if (strncmp(getdata,"<html", strlen("<html")) == 0){
	    clicon_log(LOG_WARNING,  "%s: Unexpected controller reply: %s", __FUNCTION__, getdata);
	}
	else if (xml_parse_string(getdata, NULL, &xreply) < 0)
	    clicon_log(LOG_WARNING,  "%s: xml parse error: %s", __FUNCTION__, getdata);
	else
	    clicon_log(LOG_WARNING,  "%s: Unexpected controller reply: %s", __FUNCTION__, getdata);
	*natstate = 0;
	goto ok;
    }
    if (json_parse_str(getdata, &xreply) < 0){
	clicon_log(LOG_WARNING,  "%s: json parse error: %s", __FUNCTION__, getdata);
	*natstate = 0;
	goto ok;
    }
    /* If not regular output, it is an error*/
    if (xpath_first(xreply, "output") == NULL){
	if ((x = xpath_first(xreply, "//error-message")) != NULL)
	    err = xml_body(x);
	if ((x = xpath_first(xreply, "//error-tag")) != NULL)
	    clicon_log(LOG_WARNING,  "%s: error: %s: %s", __FUNCTION__, xml_body(x), err?err:"");
	*natstate = 0;
	goto ok;
    }
    *natstate = 2;
 ok:
    retval = 0;
 done:
    if (remoteip)
	free(remoteip);
    if (xreply)
	xml_free(xreply);
    if (getdata)
	free(getdata);
    if (ub)
	cbuf_free(ub);
    if (cb)
	cbuf_free(cb);
    return retval;
}

/*!
 * @param[in]     url       URL - where to send http data to
 * @param[in]     name
 * @param[in]     cbmetr    Metric data from echo_application
 * @param[in]     timeout   Curl post request timeout in seconds
 * @param[in,out] natstate  0:none 1:enabled 2:addr&port defined 3: connected
 * @param[out]    interval  
 * @param[out]    xplugin   This is test initiator received from the controller
 */
static int
http_data(char               *url,
	  char               *name,
	  char               *id,
	  cbuf               *cbmetr,
	  uint64_t           *sseq,
	  int                *t0valid,
	  struct timeval     *t0,
	  int                *t1valid,
	  struct timeval     *t1,
	  int                 curl_timeout,
	  int                *natstate,
	  int                *interval,
	  cxobj             **xplugin)
{
    int     retval = -1;
    cbuf   *ub = NULL;
    cbuf   *cb = NULL;
    char   *getdata = NULL;
    cxobj  *xreply = NULL;
    cxobj  *x;
    char   *remoteip = NULL;
    struct timeval t2;
    int64_t i64;
    static uint64_t aseq=0;
    int     ret;
    char   *xbody;
    char   *reason = NULL;
    char   *err = NULL;

    clicon_debug(1, "%s", __FUNCTION__);
    *interval = 10000; /* 10s default, on error can be 0 */
#ifdef FUZZ
    if (fuzz)
	*interval = 1;
#endif
    if ((ub = cbuf_new()) == NULL){ /* URL */
      clicon_err(OE_UNIX, errno, "cbuf_new");
      goto done;
    }
    if ((cb = cbuf_new()) == NULL){ /* data */
      clicon_err(OE_UNIX, errno, "cbuf_new");
      goto done;
    }
    cprintf(cb, "<input>");
    cprintf(cb, "<name>%s</name>", name);
    cprintf(cb, "<userid>%s</userid>", id);
    cprintf(cb, "<sseqn>%" PRIu64 "</sseqn>", *sseq);
    cprintf(cb, "<aseqn>%" PRIu64 "</aseqn>", aseq++);
    if (*t0valid){
	cprintf(cb, "<t0>%ld.%06ld</t0>", t0->tv_sec, t0->tv_usec);
	*t0valid = 0;
    }
    if (*t1valid){
	cprintf(cb, "<t1>%ld.%06ld</t1>", t1->tv_sec, t1->tv_usec);
	*t1valid = 0;
    }
    gettimeofday(&t2, NULL);
    cprintf(cb, "<t2>%ld.%06ld</t2>", t2.tv_sec, t2.tv_usec);
    if (cbmetr && cbuf_len(cbmetr))
	cprintf(cb, "%s", cbuf_get(cbmetr));

    cprintf(cb, "</input>");
    cprintf(ub, "%s/restconf/operations/grideye:agent-data", url);
    /* XXX return is JSON */
    ret = url_post(cbuf_get(ub), cbuf_get(cb), "Content-Type: application/yang-data+xml",
		   NULL, curl_timeout, &getdata, &remoteip);
    switch (ret){
    case -2: /* fatal */
	goto done;
	break;
    case -1: /* non-fatal */
	*natstate = 0;
	goto ok;
    default:
	break;
    }
    gettimeofday(t1, NULL);
    *t1valid = 1;
    /* XXX KLUDGE TO SEE IF IT IS XML. ERROR COMES AS HTML 
     * In all cases, go back to callhome mode.
     * If HTML, then we cant use XML parser, since it is not properly formed.
     */
    if (getdata[0] == '<'){
	if (strncmp(getdata,"<html", strlen("<html")) == 0){
	    clicon_log(LOG_WARNING,  "%s: Unexpected controller reply: %s", __FUNCTION__, getdata);
	}
	else if (xml_parse_string(getdata, NULL, &xreply) < 0)
	    clicon_log(LOG_WARNING,  "%s: xml parse error: %s", __FUNCTION__, getdata);
	else
	    clicon_log(LOG_WARNING,  "%s: Unexpected controller reply: %s", __FUNCTION__, getdata);
	*natstate = 0;
	goto ok;
    }
    if (json_parse_str(getdata, &xreply) < 0){
	clicon_log(LOG_WARNING,  "%s: json parse error: %s", __FUNCTION__, getdata);
	goto ok;
    }
    /* If not regular output, it is an error XXX // needed for old controller?
     * Actually we get  <output>      <rpc-error>
     */
    if (xpath_first(xreply, "output") == NULL ||
	xpath_first(xreply, "//rpc-error") != NULL){
	if ((x = xpath_first(xreply, "//error-message")) != NULL)
	    err = xml_body(x);
	if ((x = xpath_first(xreply, "//error-tag")) != NULL)
	    clicon_log(LOG_WARNING,  "%s: error: %s: %s", __FUNCTION__, xml_body(x), err?err:"");
	else
	    clicon_log(LOG_WARNING,  "%s: unspecified error from controller", __FUNCTION__);
	*natstate = 0;
	goto ok;
    }
    if ((x = xpath_first(xreply, "//interval")) != NULL){
	xbody = xml_body(x);
	*interval = atoi(xbody);
    }
    if ((x = xpath_first(xreply, "//sseqn")) != NULL){
	xbody = xml_body(x);
	*sseq = atoi(xbody);
    }
    if ((x = xpath_first(xreply, "//t0")) != NULL){
	if ((xbody = xml_body(x)) == NULL){
	    clicon_log(LOG_WARNING,  "%s: No t0 timestamp", __FUNCTION__);
	    *natstate = 0;
	    goto ok;
	}
	if (parse_dec64(xbody, 6, &i64, &reason) < 0){
	    clicon_err(OE_XML, errno, "parse_dec64: %s", xbody);
	    goto done;
	}
	if (reason){
	    clicon_log(LOG_WARNING,  "%s: Invalid timestamp %s: %s", __FUNCTION__, xbody, reason);
	    *natstate = 0;
	    goto ok;
	}
	t0->tv_sec = i64/1000000;;
	t0->tv_usec = i64%1000000;
	*t0valid = 1;
    }
    if ((x = xpath_first(xreply, "output")) != NULL)
	if (xml_copy(x, *xplugin) < 0)
	    goto done;
 ok:
    retval = 0;
 done:
    clicon_debug(1, "%s retval:%d", __FUNCTION__, retval);
    if (reason)
	free(reason);
    if (remoteip)
	free(remoteip);
    if (xreply)
	xml_free(xreply);
    if (getdata)
	free(getdata);
    if (ub)
	cbuf_free(ub);
    if (cb)
	cbuf_free(cb);
    return retval;
}


/* For linux /proc */
#define PROC_CPUINFO "/proc/cpuinfo"
static int
get_system_info(char **info)
{
    int   retval = -1;
    FILE *f = NULL;
    char  buf[1024];
#ifdef __APPLE__
    struct utsname name;
    if (uname(&name) < 0){
      clicon_err(OE_UNIX, errno, "uname");
      goto done;
    }
    snprintf(buf, 1024, "%s %s", name.sysname, name.release);
    if ((*info = strdup(buf))==NULL){
      clicon_err(OE_UNIX, errno, "strdup");
      goto done;
    }
#else

    char *line;
    char *s;

    if ((f = fopen(PROC_CPUINFO, "r")) == NULL)
	goto done;
    while ((line = fgets(buf, sizeof(buf), f)) != NULL){
	if ((s = strstr(line, "model name")) == NULL)
	    continue;
	s+=strlen("model name")+3;
	if (s[strlen(s)-1] == '\n')
	    s[strlen(s)-1] = '\0';
	if ((*info = strdup(s))==NULL){
	    clicon_err(OE_UNIX, errno, "strdup");
	    goto done;
	}
	break;
    }
#endif
    retval = 0;
 done:
    if (f != NULL)
	fclose(f);
    return retval;
}

static void
grideye_sig(int arg)
{
    clicon_log(LOG_NOTICE, "grideye_agent: %s: %d", __FUNCTION__, arg);
}

/*! Exit functions either called on sigterm or end of main */
static void
doexit(int arg)
{
    struct timeval dur;
    void          *handle = NULL;
    struct plugin *p;

    clicon_log(LOG_NOTICE, "grideye_agent: %s: %d", __FUNCTION__, arg);
    timersub(&lastpkt, &firstpkt, &dur);

    if (pidfile)
	unlink(pidfile);
    clicon_log(LOG_NOTICE, "grideye_agent: %s: Terminated: Received %d packets (term) during %ld.%03ld secs",
	    hostname, pkts, dur.tv_sec, dur.tv_usec/1000);
    if (plugins){
	handle = plugins->p_handle;
/* Cant run exit functions here because we may run in interrupt stack */
	for (p = plugins; (p->p_api!=NULL); p++){
	    if (p->p_filename)
		free(p->p_filename);
	    if (p->p_name)
		free(p->p_name);
	}
	free(plugins);
	plugins = NULL;
	if (handle)
	    dlclose(handle);
    }
    while (s_list != NULL)
	s_rm(s_list);
    exit(0);
}

static void
usage(char *argv0)
{
    fprintf(stderr, "usage:\t%s [options]*    Receive UDP packets on socket\n"
	    "where options are:\n"
	    "\t-h \t\tHelp text\n"
	    "\t-D \t\tDebug\n"
	    "\t-F \t\tRun in foreground and log to stderr\n"
	    "\t-v \t\tPrint version\n"
	    "\t-q \t\tQuiet\n"
	    "\t-e <eid64> \tDevice identifier (random if not given)\n"
	    "\t-t <s> \t\tCallhome timeout in seconds (if idle) (default:%d)\n"
	    "\t-t <s> \t\tCURL timeout in seconds (if idle) (default:%d)\n"
	    "\t-f <filename>\tLog to file\n"
	    "\t-i <ifname>\t(Local) receiving interface name (see -a)\n"
	    "\t-a <host>\t(Local) hostname or IPv4 address to listen to (see -i) \n"
	    "\t-l <port> Local port\n"
	    "\t-W <dir> \tWorking directory for disk i/o (default: %s). Two\n"
	    "\t\t\tfiles will be created, %s and %s\n"
	    "\t-u <url>\tCall home URL. Send if no rx traffic in -t s\n"
	    "\t-I <id>\t\tId to use with -u\n"
	    "\t-N <name>\tName to use in logs and callhome. default is hostname\n"
#ifdef FUZZ
	    "\t-Z \t\tFuzz (afl) simulation\n"
#endif
	    "\t-w [ifname]\tWireless interface\n"
	    "\t-P <dir>\tPlugin directory(default: %s)\n"
	    "\t-z \t\tKill other config daemon and exit\n"
	    "\t-k <pidfile> \tPidfile, default: %s\n"
	    "\t-s \t\tDon't verify the servers SSL certificate, MUCH less secure.\n"
	    "\t-s -s \tConnection succeeds regardless of the names in the certificate.\n",
	    argv0,
	    CALLHOME_DEFAULT,
	    CURL_TIMEOUT_DEFAULT,
	    DISKIO_DIR,
	    DISKIO_LARGEFILE,
	    DISKIO_WRITEFILE,
	    PLUGINDIR,
	    GRIDEYE_AGENT_PIDFILE
	    );
    exit(0);
}

int
main(int   argc,
     char *argv[])
{
    char               *argv0;
    int                 retval = -1;
    int                 c;
    struct in_addr      inaddr = {0, };
    unsigned short      localport; /* local port */
    fd_set              fdset;
    int                 callhome_timeout;
    char               *filename;
    FILE               *f;
    uint64_t            eid64;
    char                eid64str[24];
    int                 n;
    char               *diskio_dir;
    char               *diskio_largefile = NULL;
    char               *diskio_writefile = NULL;
    int                natstate; /* state: 0:none 1:enabled 2:addr&port defined */
    char               *callhome_url;
    struct timeval     tv;
    struct timeval     trnd;
    char               *userid = NULL;
    char               *wi = NULL; /* Wireless interface */
    //char               *plugin_dir = NULL;
    struct plugin      *p;
    struct grideye_plugin_api *api;
    int                foreground;
    int                slen;
    int                zap;
    pid_t              pid;
    struct stat        st;
    char               *info = NULL;
    int                errno0;
    char               pidfile[MAXPATHLEN];
    cxobj             *xtest = NULL;
    int                interval = 10000;
    int                ct0valid = 0; /* If ct0 and ct1 are valid */
    struct timeval     ct0;
    int                ct1valid = 0; /* If ct0 and ct1 are valid */
    struct timeval     ct1;
    uint64_t           sseq = 0;
    int                curl_timeout = CURL_TIMEOUT_DEFAULT;
    cxobj             *xym=NULL; /* XML yang metric tree */
    char              *yangmetric;

    /* Initialization */
    argv0 = argv[0];
    localport = 0;
    natstate = 1;
    callhome_url = NULL;
    callhome_timeout = CALLHOME_DEFAULT; /* timeout for call home */
    filename = NULL;
    f = NULL;
    gettimeofday(&trnd, NULL);
    srandom(trnd.tv_usec); /* init random */
    eid64 = random();
    eid64 = eid64<<32;
    eid64 |= random();
    zap = 0;
    diskio_dir  = DISKIO_DIR;
    plugin_dir = PLUGINDIR;
    plugins = NULL;
    foreground = 0;
    strncpy(pidfile, GRIDEYE_AGENT_PIDFILE, sizeof(pidfile)-1);
    ssl_verifypeer = 0;
#ifdef FUZZ
    fuzz = 0;
#endif

    /* Hostname for logs and callbacks, overwritten by -N */
    if (gethostname(hostname, sizeof(hostname)) < 0) {
	clicon_err(OE_UNIX, errno, "gethostname");
	exit(0);
    }

    clicon_log_init("grideye_agent", LOG_INFO, CLICON_LOG_STDERR);
    while ((c = getopt(argc, argv, GRIDEYE_AGENT_OPTS)) != -1){
	switch (c) {
	case 'h' : /* help */
	    usage(argv0);
	    break;
	case 'D' : /* debug */
	    debug++;
	    break;
	case 'F' : /* foreground */
	    foreground = 1;
	    break;
	case 'v' : /* version */
	    fprintf(stderr, "Grideye v%s prototype\n", GRIDEYE_VERSION);
	    fprintf(stderr, "%s\n", GRIDEYE_BUILDSTR);
	    exit(0);
	    break;
	case 't' : /* callhome timeout */
	    callhome_timeout = atoi(optarg);
	    break;
	case 'q' : /* be (more) quiet */
	    quiet++;
	    break;
	case 'e' : /* eid */
	    eid64 = atoll(optarg);
	    break;
	case 'f' : /* filename */
	    filename = optarg;
	    break;
	case 'i' : /* interface  (overridden by -a) */
	    if (ifname2addr(optarg, &inaddr) < 0)
		goto done;
	    break;
	case 'a': /* Local address or hostname (overrides -i) */
	    if (host2addr(optarg, &inaddr) < 0) {
		fprintf(stderr, "Invalid address: %s\n", optarg);
		usage(argv0);
	    }
	    break;
	case 'l' : /* local port */
	    localport = atoi(optarg);
	    if (localport <= 0){
		fprintf(stderr, "Invalid local port: %s\n", optarg);
		usage(argv0);
	    }
	    break;
	case 'W':    /* Disk I/O directory */
	    diskio_dir = optarg;
	    break;
	case 'u':    /* URL used with callback */
	    callhome_url = optarg;
	    break;
	case 'I':    /* user id used with callback url */
	    userid = optarg;
	    break;
	case 'N':    /* Name to use with -u and in logs */
	    strncpy(hostname, optarg, sizeof(hostname));
	    hostname[sizeof(hostname) - 1]= '\0';
	    break;
	case 'w':    /* Wireless interface */
	    wi = optarg;
	    break;
	case 'P':    /* Grideye_agent plugin dir*/
	    plugin_dir = optarg;
	    break;
	case 'z': /* Zap other process */
	    zap++;
	    break;
	case 'k':    /* PID file*/
	    strncpy(pidfile, optarg, sizeof(pidfile)-1);
	    break;
#ifdef FUZZ
	case 'Z':    /* Fuzzing simulation */
	    fuzz++;
	    interval = 1;
	    break;
#endif
	case 's':    /* SSL verify peer */
	    ssl_verifypeer++;
	    break;
	} /* switch */
    } /* while */
    clicon_log(LOG_DEBUG, "grideye_agent: wi:%s", wi);
    /* sensd does not want an 0x%lx but parse_uint64 does */
    snprintf(eid64str, sizeof(eid64str), "0x%" PRIu64, eid64);
    /* Get some system info */
    if (get_system_info(&info) < 0)
	goto done;
    if (pidfile_get(pidfile, &pid) < 0)
	goto done;
    if (zap){
	if (pid && pidfile_zapold(pid) < 0)
	    return -1;
	if (lstat(pidfile, &st) == 0)
	    unlink(pidfile);
	exit(0); /* OK */
    }
    else{
	if (pid){
	    clicon_err(OE_DEMON, 0, "Daemon already running with pid %d\n(Try killing it with %s -z)", 
		       pid, argv0);
	    return -1; /* goto done deletes pidfile */
	}
    }
    /* After this point we can goto done on error
     * Here there is either no old process or we have killed it,..
     */
    if (lstat(pidfile, &st) == 0)
	unlink(pidfile);
    /* Daemonize and initiate logging. Note error is initiated here to make
       demonized errors OK. Before this stage, errors are logged on stderr
       also */
    if (foreground==0){
	clicon_log_init("grideye_agent", debug?LOG_DEBUG:LOG_INFO, CLICON_LOG_SYSLOG);
	if (daemon(0, 0) < 0){
	    fprintf(stderr, "config: daemon");
	    exit(-1);
	}
    }
    /* Write pid-file */
    if ((pid = pidfile_write(pidfile)) <  0)
	goto done;
    if ((plugins = calloc(1, sizeof(struct plugin))) == NULL){
	clicon_err(OE_UNIX, errno, "calloc");
	goto done;
    }
    /* Init curl */
    if (curl_global_init(CURL_GLOBAL_ALL) != 0){
	clicon_err(OE_UNIX, errno, "curl_global_init");
	goto done;
    }

    /* Load test plugins, and call their init functions */
    clicon_log(LOG_NOTICE, "grideye_agent: Plugin: Loading plugins from %s", plugin_dir);

    if (plugin_load_dir(plugin_dir, &plugins) < 0)
	goto done;
    /* Create two filenames, write file and large file for plugin setopts below */
    if ((slen = snprintf(NULL, 0, "%s/%s", diskio_dir,
			 DISKIO_WRITEFILE)) <= 0)
	goto done;
    if ((diskio_writefile = malloc(slen+1)) == NULL)
	goto done;
    snprintf(diskio_writefile, slen+1, "%s/%s", diskio_dir,
	     DISKIO_WRITEFILE);
    
    if ((slen = snprintf(NULL, 0, "%s/%s", diskio_dir,
			 DISKIO_LARGEFILE)) <= 0)
	goto done;
    if ((diskio_largefile = malloc(slen+1)) == NULL)
	goto done;
    snprintf(diskio_largefile, slen+1, "%s/%s", diskio_dir,
	     DISKIO_LARGEFILE);

    /*
     * Iterate through plugins and call getopt/setopt functions
     * See options definitions in plugin/grideye_plugin.h
     */
    for (p = plugins; (api=p->p_api)!=NULL; p++){
	if (api->gp_getopt_fn) {
	    yangmetric = NULL;

	    if (api->gp_magic == GRIDEYE_PLUGIN_PYTHON) {
		if ((yangmetric = grideye_call_method(api->gp_name,
						      (char *)api->gp_getopt_fn,
						      "yangmetric")) == NULL) {
		    clicon_log(LOG_DEBUG, "grideye_agent: Plugin: getopt(yangmetric)");
		    clicon_log(LOG_NOTICE, "grideye_agent: Plugin: Disabling %s (no writefile)",
			       p->p_name, strerror(errno));
		}
	    } else {
		if (api->gp_getopt_fn("yangmetric", &yangmetric) < 0){
		    clicon_log(LOG_DEBUG, "grideye_agent: Plugin: getopt(yangmetric)");
		    clicon_log(LOG_NOTICE, "grideye_agent: Plugin: Disabling %s (no writefile)",
			       p->p_name, strerror(errno));
		}
	    }

	    if (yangmetric) {
		if ((api->gp_input_format==NULL &&
		     strcmp(GRIDEYE_PLUGIN_INPUT_FORMAT, "json")==0)||
		    strcmp(api->gp_input_format, "json")==0){
			if (json_parse_str(yangmetric, &xym) < 0) {
				clicon_log(LOG_NOTICE, "grideye_agent: Could not parse JSON");
				goto done;
			}
		} else if ((api->gp_input_format==NULL &&
			    strcmp(GRIDEYE_PLUGIN_INPUT_FORMAT, "xml")==0)||
			   strcmp(api->gp_input_format, "xml")==0){
			if (xml_parse_string(yangmetric, NULL, &xym) < 0) {
				clicon_log(LOG_NOTICE, "grideye_agent: Could not parse XML");
				goto done;
			}
		}

		free(yangmetric);
		yangmetric = NULL;
	    }
	}

	if (api->gp_setopt_fn){
	    if (api->gp_setopt_fn("writefile", diskio_writefile) < 0){
		p->p_disable++;
		clicon_log(LOG_DEBUG, "grideye_agent: Plugin: setopt(writefile):%s",
			   diskio_writefile);
		clicon_log(LOG_NOTICE, "grideye_agent: Plugin: Disabling %s (no writefile)",
			   p->p_name, strerror(errno));
	    }
	    if (api->gp_setopt_fn("largefile", diskio_largefile) < 0){
		p->p_disable++;
		clicon_log(LOG_DEBUG, "grideye_agent: Plugin setopt(largefile):%s",
			   diskio_largefile);
		clicon_log(LOG_NOTICE, "grideye_agent: Plugin: Disabling %s (no largefile)",
			   p->p_name, strerror(errno));
	    }
	    if (api->gp_setopt_fn("device", wi) < 0){
		p->p_disable++;
		clicon_log(LOG_DEBUG, "grideye_agent: Plugin: setopt(device):%s",
			   diskio_largefile);
		clicon_log(LOG_NOTICE, "Plugin: Disabling %s (no device)",
			   p->p_name, strerror(errno));
	    }
	}
    }
    /* Write XML yang metrics tree as JSON */
    if (0)
	fprintf(stderr, "%s %s\n", diskio_largefile, diskio_writefile);
    /* Log file */
    if (filename){
	if ((f = fopen(filename, "w")) == NULL){
	    clicon_err(OE_UNIX, errno, "fopen");
	    exit(0);
	}
    }
    set_signal(SIGINT, grideye_sig, NULL);
    set_signal(SIGTERM, grideye_sig, NULL);

    if (callhome_url && userid)     /* Timeout Send a (call)home message */
	if (callhome_http(callhome_url,
			  hostname,
			  userid,
			  NULL,
			  info,
			  curl_timeout,
			  xym,
			  &natstate) < 0)
	    goto done;
    if ((xtest = xml_new("new", NULL, NULL)) == NULL)
	goto done;
    if (natstate == 2)
	if (http_data(callhome_url,
		      hostname,
		      userid,
			  NULL,
			  &sseq,
			  &ct0valid, &ct0,
			  &ct1valid, &ct1,
			  curl_timeout,
			  &natstate,
			  &interval,
			  &xtest) < 0)
	    goto done;
    tv.tv_sec = callhome_timeout;
    for (;;){
	cbuf *cb;
	FD_ZERO(&fdset);
	tv.tv_usec = 0;
	tv.tv_sec = interval/1000;
	tv.tv_usec = interval%1000;
	//clicon_log(LOG_DEBUG, "Callhome timeout: %d", callhome_timeout;)

	n = select(FD_SETSIZE, &fdset, NULL, NULL, &tv);
	/* Consider timeout to be undefined after select() returns. */
	errno0 = errno;
	if (n == -1) {
	    clicon_err(OE_UNIX, errno0, "select");
	    goto done;
	}
	/* Timeout */

	/* Check sockets */
	if (natstate != 2){
	    interval = CALLHOME_DEFAULT;
#ifdef FUZZ
	    if (fuzz)
		interval = 1;
#endif
	    if (callhome_http(callhome_url,
			      hostname,
			      userid,
				      NULL,
				      info,
				      curl_timeout,
				      xym,
				      &natstate) < 0)
			goto done;
		}
		else{
		    if ((cb = cbuf_new()) ==NULL){
			clicon_err(OE_PLUGIN, errno, "cbuf_new");
			goto done;
		    }
		    if ((retval = echo_application(xtest,
						   cb,
						   plugins)) < 0)
			goto done;
		    if (xtest){
			xml_free(xtest);
			xtest = NULL;
		    }
		    if ((xtest = xml_new("new", NULL, NULL)) == NULL)
			goto done;
		    if (http_data(callhome_url,
				  hostname,
				  userid,
				  cb,
				  &sseq,
				  &ct0valid, &ct0,
				  &ct1valid, &ct1,
				  curl_timeout,
				  &natstate,
				  &interval,
				  &xtest) < 0)
			goto done;

		    if (cb){
			cbuf_free(cb);
			cb = NULL;
		    }
		}
    } /* for */
    retval = 0;
 done:
    if (xym) /* json yang metric string*/
	xml_free(xym);
    if (xtest)
	xml_free(xtest);
#if 0
    if (callhome_url && name && userid){     /* Timeout Send a (call)home message */
	if (callhome_http(callhome_url, name, userid, localport, info,
			  &natstate, 1) < 0)
	    goto done;
    }
#endif
    if (diskio_writefile)
	free(diskio_writefile);
    if (diskio_largefile)
	free(diskio_largefile);
    doexit(0);
    return(retval);
}
