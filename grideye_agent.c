/*
  Copyright (C) 2015-2017 Olof Hagsand

  This file is part of GRIDEYE.

  GRIDEYE is free software; you can redistribute it and/or modify
  it under the terms of the GNU General Public License as published by
  the Free Software Foundation; either version 3 of the License, or
  (at your option) any later version.

  GRIDEYE is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  GNU General Public License for more details.

  You should have received a copy of the GNU General Public License
  along with GRIDEYE; see the file LICENSE.  If not, see
  <http://www.gnu.org/licenses/>.
*/

#define _GNU_SOURCE /* This is to enable O_DIRECT */
#if defined(__i386__)
#define _FILE_OFFSET_BITS 64
#endif

#include <stdio.h>
#include <stdlib.h>
#include <inttypes.h>
#include <string.h>
#include <signal.h>
#include <sys/param.h>
#include <sys/socket.h>
#include <sys/uio.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <netdb.h>
#include <unistd.h>
#include <time.h>
#include <assert.h>
#include <dirent.h>
#include <fcntl.h>
#include <dlfcn.h>
#include <errno.h>
#include <sys/time.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <sys/ioctl.h>
#include <syslog.h>
#include <net/if.h> 
#include <math.h> 
#include <curl/curl.h>
#include <sys/utsname.h>

#ifdef HAVE_LINUX_SOCKIOS_H
#include <linux/sockios.h> /* Dont remove: SIOCGIFADDR will be undefined below */
#elif defined(HAVE_SYS_SOCKIO_H)
#include <sys/sockio.h> /* Dont remove: SIOCGIFADDR will be undefined below */
#endif

#include <cligen/cligen.h>     /* cbuf */
#include <clixon/clixon.h>     /* xml, xpath, log, err */

#include "grideye_agent.h"     /* lib */
#include "grideye_plugin_v2.h" /* plugin C API */

/*
 * Global variables generated by Makefile
 */
extern const char GRIDEYE_BUILDSTR[];
extern const char GRIDEYE_VERSION[]; 

#define	SEQ_LT(a,b)	((int)((a)-(b)) < 0)
#define	SEQ_LEQ(a,b)	((int)((a)-(b)) <= 0)
#define	SEQ_GT(a,b)	((int)((a)-(b)) > 0)
#define	SEQ_GEQ(a,b)	((int)((a)-(b)) >= 0)

/* Protocol agent version. Bundle with plugin API version
 * I.e. one agent version supports one plugin version
 * But one controller must support multiple agent versions
*/
#define GRIDEYE_AGENT_VERSION 2

/* Set this to a file (prefix) and this will dump incoming binary messages */
//#define DUMPMSGFILE "grideyedump"

#define GRIDEYE_AGENT_OPTS "hDFvtqe:f:i:a:l:W:u:I:N:p:rLdw:P:zk:"

#define DISKIO_DIR        "/var/tmp"  /* in current dir */
#define DISKIO_LARGEFILE  "GRIDEYE_LARGEFILE" /* To use for random read ops */ 
#define DISKIO_WRITEFILE  "GRIDEYE_WRITEFILE" /* To use for trunc writing */
#define BUFSIZE           8*1024

#define GRIDEYE_AGENT_PIDFILE "/var/run/grideye_agent.pidfile"

/* This timeout may interfer with network timeout. It should be well above
 * interval setting (eg yang sender->round->interval
 * but may also trigger if the probe is out of reach for a period of time
 * So: either no traffic reaching the probe, or "wrong" traffic reaching,
 * Wrong being for example a new sender (the old is dead).
 */
#define CALLHOME_DEFAULT  20 /* seconds */

/* Wireless file to read status from */
#define PROC_NET_WIRELESS "/proc/net/wireless"

/* By default, this is where grideye_agent looks for plugins 
 * This is normally set in configure/Makefile as $exec_prefix/lib/grideye
 * eg /usr/local/lib/grideye.
 */
#ifndef PLUGINDIR
#define PLUGINDIR "/usr/local/lib/grideye"
#endif

/*
 * Local types 
 */
struct sender {
    struct sender  *s_next;    /* linked list */
    void           *s_sname;   /* socket name, eg sockaddr */
    socklen_t       s_snamelen;
    char           *s_name;    /* name given by sender */
    uint32_t        s_seq;
    cxobj          *s_xml;     /* XML control tree with config info received in
			        * most recdetn callhome reply */
};

/*
 * Types buffer for curl
 */
struct curlbuf{
    size_t b_len;
    char  *b_buf;
};

/* Info of a plugin. Make a vector of these for all plugins */
struct plugin{
    void                         *p_handle;
    int                           p_version;
    char                         *p_filename; /* Actual filename */
    char                         *p_name;     /* Name corresponds to yang spec */
    int                           p_disable; /* something failed */
    struct grideye_plugin_api_v2 *p_api;
};

/*
 * Local variables
 */
static struct sender *s_list = NULL;
/* XXX: should be moved as doexit code is moved */
static char hostname[128] = {0,};/* name of this host, -N or gethostname */
static int  pkts = 0;		 /* packets received counter */
static int  errpkts = 0;	 /* dropped packets received counter */
static int  nr_nobufs = 0;       /* global variable to log of buf overflows */
struct timeval firstpkt, lastpkt;
static int     quiet = 0;
static struct plugin *plugins = NULL;
static char    *pidfile = GRIDEYE_AGENT_PIDFILE;

/*! Return number of plugins in plugins vector. This is one less than vectorlen
 */
static int
plugins_len(struct plugin *plugins)
{
    int            i=0;
    struct plugin *p;

    i = 0;
    for (p = plugins; p->p_api!=NULL; p++, i++);
    return i;
}

/*! Load a specific plugin, call its init function and add it to plugins list
 * If init function fails (not found, wrong version, etc) print a log and dont
 * add it.
 */
static int 
grideye_plugin_load(void          *handle,
		    char          *name,
		    char          *filename,
		    struct plugin *plugins[]
		    )
{
    int                           retval = -1;
    char                         *dlerrcode;
    grideye_plugin_init_t        *initfun;
    struct grideye_plugin_api_v2 *api;
    int                           len;

    /* Try v2 */
    initfun = dlsym(handle, PLUGIN_INIT_FN_V2);
    if ((dlerrcode = (char*)dlerror()) != NULL) {
	clicon_log(LOG_WARNING, "%s Skipping %s", __FUNCTION__, dlerrcode); 
	goto fail;
    }
    if ((api = initfun(GRIDEYE_PLUGIN_VERSION)) == NULL) {
	clicon_log(LOG_WARNING, "grideye_agent: %s: failed when running init function %s: %s", 
		   filename, PLUGIN_INIT_FN_V2, errno?strerror(errno):"");
	goto fail;
    }
    if (api->gp_version != GRIDEYE_PLUGIN_VERSION){
	clicon_log(LOG_WARNING, "grideye_agent: %s Unexpected plugin version number: %d", 
		   filename, api->gp_version);
	goto fail;
    }
    if (api->gp_magic != GRIDEYE_PLUGIN_MAGIC){
	clicon_log(LOG_WARNING, "grideye_agent: %s: Wrong plugin magic number: %x", 
		   filename, api->gp_magic);
	goto fail;
    }
    len = plugins_len(*plugins);
    if ((*plugins = realloc(*plugins, (len+2)*sizeof(struct plugin))) == NULL){
	clicon_err(OE_UNIX, errno, "realloc");
	goto done;
    }
    memcpy(&(*plugins)[len+1], &(*plugins)[len], sizeof(struct plugin));
    (*plugins)[len].p_handle = handle;
    if (((*plugins)[len].p_filename = strdup(name)) == NULL){
	clicon_err(OE_UNIX, errno, "strdup");
	goto done;
    }
    /* Plugin name should be read for plugin itself, but use filename - ext */
    if (((*plugins)[len].p_name = strdup(api->gp_name)) == NULL){
	clicon_err(OE_UNIX, errno, "strdup");
	goto done;
    }
    (*plugins)[len].p_api = api;
    clicon_log(LOG_WARNING, "grideye_agent: Plugin %s loaded from %s", name, filename);
    retval = 0;
 done:
    if (retval < 0)
	dlclose(handle);
    return retval;
 fail: /* plugin load failed, continue */
    retval = 0;
    goto done;
}

/*! Load grideye agent plugins from directory, return handles in vector
 * @param[in]  dir      name of directory where grideye .so plugins reside
 * @param[out] plugins  Null-terminated vector of plugin handles.
 */
static int
plugin_load_dir(char          *dir,
		struct plugin *plugins[])
{
    int            retval = -1;
    DIR           *dirp = NULL;
    struct dirent  dent;
    struct dirent *dresp;
    void          *handle = NULL;
    int            res;
    char          *name;
    int            off;
    char          *filename;
    int            len;

    if ((dirp = opendir(dir)) == NULL) {
	clicon_err(OE_PLUGIN, errno, "opendir(%s)", dir);
	if (errno == ENOENT)
	    fprintf(stderr, "No grideye_agent test .so plugins found in %s\n", 
		    dir);
	goto done;
    }
    /*
     * dirent->d_name is name of directory entry, if dresp is NULL the iteration
     * is done
     */
   for (res = readdir_r(dirp, &dent, &dresp); 
	dresp; 
	res = readdir_r (dirp, &dent, &dresp)){
       if (res != 0) {
	   clicon_err(OE_UNIX, errno, "readdir");
	   goto done;
       }
       /* match .so */
       name = dent.d_name;
       off = strlen(name)-5;
       if (off<=0 || strcmp(".so.1", name+off)!=0)
	   continue;
       len = strlen(dir)+1+strlen(name)+1;
       if ((filename = malloc(len)) == NULL){
	   clicon_err(OE_UNIX, errno, "malloc");
	   goto done;
       }
       snprintf(filename, len, "%s/%s", dir, name);

       dlerror();    /* Clear any existing error */
       if ((handle = dlopen(filename, RTLD_NOW)) == NULL) {
	   clicon_err(OE_UNIX, 0, "dlopen: %s", (char*)dlerror());
	   goto done;
       }
       if (grideye_plugin_load(handle, name, filename, plugins) < 0){
	   free(filename);
	   goto done;
       }
       free(filename);
   }
    retval = 0;
 done:
    if (dirp)
	closedir(dirp);
    return retval;
}

#ifdef notyet
static int
plugin_unload (void)
{
    int   retval = -1;

    dlerror();    /* Clear any existing error */
    if (dlclose(plg->p_handle) != 0) {
	clicon_err(OE_PLUGIN, errno, "dlclose");
	goto done;
    }
    retval = 0;
 done:
    return retval;
}
#endif /* notyet */

/*! Get (reply) data from server
 */
static size_t
curl_get_cb(void  *ptr, 
	    size_t size, 
	    size_t nmemb, 
	    void  *userdata)
{
    struct curlbuf *buf = (struct curlbuf *)userdata;
    int len;

    len = size*nmemb;
    if ((buf->b_buf = realloc(buf->b_buf, buf->b_len+len+1)) == NULL)
	return 0;
    memcpy(buf->b_buf+buf->b_len, ptr, len);
    buf->b_len += len;
    buf->b_buf[buf->b_len] = '\0';
    //    fprintf(stderr, "%s: %s\n", __FUNCTION__, buf->b_buf);
    return len;
}


/*! Send a curl POST request
 * @param[out] getdata  Pointer to return data, if given, free with malloc
 * @param[out] remoteip Pointer remote IP address in string format
 * @retval    -1   fatal error
 * @retval     0   expect set but did not expected return or other non-fatal error
 * @retval     1   ok
 * Note: Code taken from grideye
 * Note: curl_easy_perform blocks
 * Note: New handle is created every time, the handle can be re-used for better TCP performance
 */
static int
url_post(char *url, 
	 char *username, 
	 char *passwd, 
	 char *putdata, 
	 char *expect, 
	 char **getdata,
	 char **remoteip)
{
    CURL      *curl = NULL;
    char      *err = NULL;
    int        retval = -1;
    cxobj     *xr = NULL; /* reply xml */
    struct curlbuf cb = {0, };
    CURLcode   errcode;
    char      *ip = NULL;

    /* Try it with  curl -X PUT -d '*/
    clicon_log(LOG_DEBUG,  "%s:  curl -X POST -d '%s' %s (%s:%s)",
		 __FUNCTION__, putdata, url, 
	       username?username:"", passwd?passwd:"");

    /* Set up curl for doing the communication with the controller */
    if ((curl = curl_easy_init()) == NULL) {
	clicon_err(OE_PLUGIN, errno, "curl_easy_init");
	goto done;
    }
    if ((err = malloc(CURL_ERROR_SIZE)) == NULL) {
	clicon_err(OE_UNDEF, errno, "malloc");
	goto done;
    }
    curl_easy_setopt(curl, CURLOPT_URL, url);
    if (username)
	curl_easy_setopt(curl, CURLOPT_USERNAME, username);
    if (passwd)
	curl_easy_setopt(curl, CURLOPT_PASSWORD, passwd);
    curl_easy_setopt(curl, CURLOPT_ERRORBUFFER, err);

    curl_easy_setopt(curl, CURLOPT_WRITEFUNCTION, curl_get_cb);
    curl_easy_setopt(curl, CURLOPT_WRITEDATA, &cb);

    curl_easy_setopt(curl, CURLOPT_POST, 1);
    curl_easy_setopt(curl, CURLOPT_POSTFIELDS, putdata);
    curl_easy_setopt(curl, CURLOPT_POSTFIELDSIZE, strlen(putdata));
    if (debug>1)
	curl_easy_setopt(curl, CURLOPT_VERBOSE, 1);   
    
    curl_easy_setopt(curl, CURLOPT_TIMEOUT, 600); /* 10 min */
    
    if ((errcode = curl_easy_perform(curl)) != CURLE_OK){
	clicon_log(LOG_NOTICE, "%s: curl_easy_perform: %s(%d)", __FUNCTION__, err, errcode);
	retval = 0;
	goto done; 
    }
    if (remoteip && 
	curl_easy_getinfo(curl, CURLINFO_PRIMARY_IP, &ip) == CURLE_OK)
	if ((*remoteip = strdup(ip)) == NULL){
	    clicon_err(OE_UNIX, errno, "strdup");
	    goto done;
	}

    if (expect){
	if (cb.b_buf == NULL){
	    clicon_err(OE_PLUGIN, 0, "%s: no match", __FUNCTION__);
	    retval = 0;
	    goto done;
	}
	else{
	    clicon_log(LOG_DEBUG,  "%s: reply:%s", __FUNCTION__, cb.b_buf);
	    if (xml_parse_string(cb.b_buf, NULL, &xr) < 0){
		clicon_log(LOG_WARNING,  "%s: %s", __FUNCTION__, cb.b_buf);
		goto done;
	    }
	    if (xpath_first(xr, expect) == NULL){
		clicon_err(OE_PLUGIN, 0, "%s: no match", __FUNCTION__);
		retval = 0;
		goto done;
	    }
	}
    }
    if (getdata && cb.b_buf){
	*getdata = cb.b_buf;
	cb.b_buf = NULL;
    }
    retval = 1;
  done:
    if (err)
	free(err);
    if (xr != NULL)
	xml_free(xr);
    if (cb.b_buf)
	free(cb.b_buf);
    if (curl)
	curl_easy_cleanup(curl);   /* cleanup */ 
    return retval;
}


static int
s_rm(struct sender *s)
{
    struct sender   *c;
    struct sender  **s_prev;

    s_prev = &s_list;
    for (c = *s_prev; c; c = c->s_next){
	if (c == s){
	    if (s->s_sname)
		free(s->s_sname);
	    if (s->s_xml)
		xml_free(s->s_xml);
	    if (s->s_name)
		free(s->s_name);
	    *s_prev = c->s_next;
	    free(s);
	    break;
	}
	s_prev = &c->s_next;
    }
    return 0;
}

/*! Register a sender, lock enum and source from this sender 
 */
static struct sender *
s_add(void      *sname, 
      socklen_t  snamelen)

{
    struct sender   *s = NULL;

    if ((s = (struct sender *)malloc(sizeof(*s))) == NULL){
	clicon_err(OE_UNIX, errno, "malloc");
	goto done;
    }
    memset(s, 0, sizeof(*s));
    s->s_snamelen = snamelen;
    if ((s->s_sname = malloc(snamelen)) == NULL){
	clicon_err(OE_UNIX, errno, "malloc");
	goto done;
    }
    memcpy(s->s_sname, sname, snamelen);
    /* Always remove s_list to ensure single sender only */
    if (s_list)
	s_rm(s_list);
    s->s_next = s_list;
    s_list = s;
 done:
    return s;
}

static struct sender *
s_find(void      *sname, 
       socklen_t  snamelen)
{
    struct sender *s;

    for (s = s_list; s; s = s->s_next)
	if (s->s_snamelen == snamelen && 
	    memcmp(sname, s->s_sname, snamelen)==0)
	    return s;
    return NULL;
}

/*
 * Format of sendbuf:
 * sequence:32
 * eid64:64
 * timeval:64
 */
static int
send_one_agent(int              s, 
	       struct sockaddr *addr, 
	       int              addrlen, 
	       char            *buf, 
	       int              len)
{
    int retval = -1;

    if (sendto(s, buf, len, 0x0, addr, addrlen) < 0){
	switch (errno){
	case ENOBUFS: /* try again if ifq is empty */
	    nr_nobufs++;
	    clicon_log(LOG_WARNING,  "sendto %s %s", __FUNCTION__, strerror(errno));
	    return 0;
	    break;
	case ENETUNREACH: /* try again */
	    clicon_log(LOG_WARNING,  "sendto %s %s", __FUNCTION__, strerror(errno));
	    return 0;
	    break;
	default:
	    clicon_err(OE_UNIX, errno, "sendto");
	    goto done;
	}
    }
    retval = 0;
 done:
    return retval;
}


/*! Received grideye data packet. Make application emulation
 * @param[in]  snd     Sender of received data packet 
 * @param[in]  payload String payload in data packet
 * @retval -1  Fatal error
 * @retval  0  Error in packet, drop and continue
 * @retval  1  OK
 */
static int
echo_application(struct sender *snd,
		 char          *myname,
		 char          *payload,
		 cbuf          *cb,
		 struct plugin  plugins[])
{
    int                retval = -1;
    cxobj             *xcontrol = NULL;
    struct plugin     *p;
    uint64_t          *v = NULL;
    int64_t           *vi = NULL;
    struct grideye_plugin_api_v2 *api;
    int                i;
    int               *invec = NULL;
    char             **pvec = NULL;
    int                plen;
    char              *pstr;
    char              *argstr;
    char              *pp;
    int                pret;
    char              *str = NULL;
    
    clicon_log(LOG_DEBUG, "%s payload:%s", __FUNCTION__, payload);
    if ((xcontrol = snd->s_xml) == NULL){ /* <grideye> */
	clicon_log(LOG_WARNING, "%s: Expected xml template when receiving data", 
		   __FUNCTION__);
	retval = 0; 	    /* sanity check failed, just continue */
	errpkts++;
	goto done;
    }
    /* Look at payload in data packets */
    if (payload){ 
	/* This is the xml in the meta/control data eg <grideye><version>0...*/
	if ((pvec = clicon_strsep(payload, ";", &plen)) == NULL)
	    goto done;	
	if (plen < 2){
	    clicon_log(LOG_ERR, "%s: Sender expected at least <version>;<name> received only %d arguments in payload", 
		       __FUNCTION__, plen);
	    retval = 0; 	    /* sanity check failed, just continue */
	    errpkts++;
	    goto done;
	}
	if (atoi(pvec[0]) != GRIDEYE_AGENT_VERSION){
	    clicon_log(LOG_ERR, "%s: Sender version %d expected, received %s", 
		       __FUNCTION__, GRIDEYE_AGENT_VERSION, pvec[0]);
	    retval = 0; 	    /* sanity check failed, just continue */
	    errpkts++;
	    goto done;
	}
	if (strcmp(pvec[1], myname)){
	    clicon_log(LOG_ERR, "%s: Sender expected name %s but received %s", 
		       __FUNCTION__, myname, pvec[1]);
	    retval = 0; 	    /* sanity check failed, just continue */
	    errpkts++;
	    goto done;
	}
	for (i=2; i<plen; i++){
	    pstr = pvec[i];
	    /* XXX: Argument handling is primitive, only
	     *   fn(arg), fn(arg,arg) 
	     * where the plugin test function must handle the arguments.
	     * Does not handle other input formats
	     */
	    if ((pp = index(pstr, '(')) != NULL)
		*pp = '\0';
	    argstr = pp+1;
	    if ((pp = index(argstr, ')')) != NULL)
		*pp = '\0';
	    for (p = plugins; (api=p->p_api)!=NULL; p++){
		if (p->p_disable)
		    continue;
		if (strcmp(p->p_name, pstr))
		    continue;
		if (api->gp_test_fn){
		    clicon_log(LOG_DEBUG, "%s name:%s(%s)",
			       __FUNCTION__, p->p_name, argstr);
		    if ((pret = api->gp_test_fn(argstr, &str)) < 0){
			clicon_log(LOG_NOTICE, "plugin %s failed: retval:%d str:%s", p->p_name, pret, str);
			continue;
		    }
		    if (str){
			cprintf(cb, "%s", str); 
			free(str);
			str = NULL;
		    }		    
		    break;
		}
	    }
	}
    } /* payload */
    clicon_log(LOG_DEBUG, "%s return:%s", __FUNCTION__, cbuf_get(cb));
    retval = 1; /* OK */
 done:
    if (pvec)
	free(pvec);
    if (invec)
	free(invec);
    if (v)
	free(v);
    if (vi)
	free(vi);
    return retval;
}

/*! Receive a packet, do stuff, and return it
 *                          no application monitoring
 * @param[in]      eid64str EID64 string, given or random for this agent
 * @param[in]      wi       Wireless interface name, or NULL if no wlan tests
 * @param[in]      name     If set with -n the name
 * @param[oit]     ok       Set to 1 if an OK (eg known sender) pkt arrived
 * xcontrol:  Ctrl hdr has been received and this is the one
 * snd:  0    A data packet has been received from an unregistered sender
 * snd:  1    A data packet has been received from a registered sender
 *     xcontrol  snd
 *       0       0           No ctrl hdr has been received
 *       0       1  
 *       1       0           Most recent ctrl hdr
 *       1       1  
 *------------------------------
 */
static int 
echo_packet(int            s, 
	    struct timeval t1, /* when received */
	    char          *buf, 
	    int            buflen, 
	    char          *eid64str,
	    int            loss,
	    int            reorder,
	    int            duplicate,
	    char          *wi,
	    struct plugin  plugins[],
	    char          *myname,
	    int           *ok
	    )
{
    int                retval = -1;
    struct msghdr      msg;
    struct iovec       iov[1];
    struct cmsghdr    *cmsg;
    struct timeval     t0; /* from sender */
    struct timeval     t2;
    struct timeval     dt;  /* t1-t0 */
    char               cmsgbuf[64];
    struct twoway_hdr  th;
    uint32_t           tag;
    cbuf              *cb = NULL; /* return payload */
    int                fromlen;
    struct sockaddr_in from={0,};
    uint32_t           sseq = 0; // debug only
    uint32_t           rlen = 0;
    uint32_t           slen;
    char              *dpayload = NULL;
    struct sender     *snd = NULL; /* Sender of received data packet */
    int                len;
    cxobj             *xpayload = NULL;
    int                ver;
    enum mtype         mtype;

    //    xr = NULL;
    memset(&msg, 0, sizeof(msg));
    memset(iov, 0, sizeof(iov));
    iov[0].iov_base = buf;
    iov[0].iov_len  = buflen;
    msg.msg_iov     = iov;
    msg.msg_iovlen  = 1;
    fromlen = sizeof(from);
    msg.msg_name = &from;
    msg.msg_namelen = fromlen;
    memset(cmsgbuf, 0, 64);
    cmsg = (struct cmsghdr *)cmsgbuf;
    msg.msg_control = cmsg;
    msg.msg_controllen = 64;

    /* Here is where the message is actually read */
    if ((len = recvmsg(s, &msg, 0x0)) < 0){
	clicon_err(OE_UNIX, errno, "recvmsg");
	goto done;
    }
    clicon_log(LOG_DEBUG, "%s: recvmsg from: %s:%hu", __FUNCTION__, 
	       inet_ntoa(from.sin_addr),
	       ntohs(from.sin_port)
	       );
    if (len == 0){
	clicon_log(LOG_WARNING, "%s: close socket, len=0", __FUNCTION__);
	goto done;
    }
    if (len < 8){
	clicon_log(LOG_WARNING, "%s: dropped packet len:%d", 
		   __FUNCTION__, len);
	retval = 0; 	    /* sanity check failed, just continue */
	errpkts++;
	goto done;
    }
#if 1
    clicon_log(LOG_DEBUG, "%s: pkt dump: [%02x%02x%02x%02x %02x%02x%02x%02x]", 
	       __FUNCTION__, 
	       buf[0]&0xff, buf[1]&0xff, buf[2]&0xff, buf[3]&0xff,
	       buf[4]&0xff, buf[5]&0xff, buf[6]&0xff, buf[7]&0xff);
#endif

#ifdef DUMPMSGFILE
    /* This is for record / replay with nc -u */
    {
	static int ii=0;
	char filename[1024];
	FILE *f;
	snprintf(filename, 1024, "%s%d", DUMPMSGFILE, ii++);
	if ((f = fopen(filename, "w")) == NULL){
	    clicon_err(OE_UNIX, errno, "fopen");
	    goto done;
	}
	fwrite(buf, 1, len, f);
	fclose(f);
    }
#endif
    /* Peek straight into message before decoding, see twoway_hdr */
    ver   = buf[0]; 
    mtype = buf[1]; 
    tag   = ((int*)buf)[1]; /* Second 32-bit word for twoway. */
    if (ver != PROTO_VERSION){
	clicon_log(LOG_WARNING, "%s: dropped version:'%d'", 
		   __FUNCTION__, ver, ver);
	retval = 0; 	    
	errpkts++;
	goto done;
    }
    if (ntohl(tag) != TWOWAY_TAG){
	clicon_log(LOG_WARNING, "%s: unexpected tag :0x%x", 
		   __FUNCTION__, ntohl(tag));
	retval = 0; 	    
	errpkts++;
	goto done;
    }
    if (mtype != MTYPE_TWOWAY){
	clicon_log(LOG_WARNING, "%s: Not expected message type :%d", 
		   __FUNCTION__, mtype);
	retval = 0; 	    /* sanity check failed, just continue */
	errpkts++;
	goto done;
    }
    switch (mtype){
    case MTYPE_TWOWAY:
	clicon_log(LOG_DEBUG, "%s: MTYPE_TWOWAY", __FUNCTION__);
	/* Check sender registered in callhome_http*/
	if ((snd = s_find(msg.msg_name, msg.msg_namelen)) == NULL){
	  clicon_log(LOG_DEBUG, "grideye_agent: Unregistered twoway sender %s:%hu",
		     inet_ntoa(from.sin_addr), ntohs(from.sin_port));
	    retval = 0; 	    /* sanity check failed, just continue */
	    errpkts++;
	    goto done;
	}
	if (decode_twoway(buf, len, &th, &dpayload, &rlen) < 0){
	    clicon_log(LOG_DEBUG, "%s: dropped packet decode_twoway len:%d", 
		       __FUNCTION__, len);
	    retval = 0; 	    /* sanity check failed, just continue */
	    errpkts++;
	    goto done;
	}
	if (reorder){
	    if (reorder == th.th_seq0){
		clicon_log(LOG_DEBUG, "Reorder %d -> %d", th.th_seq0, th.th_seq0+1);
		th.th_seq0 = th.th_seq0+1;
	    }
	    else if (reorder+1 == th.th_seq0){
		clicon_log(LOG_DEBUG, "Reorder %d -> %d", th.th_seq0, th.th_seq0-1);
		th.th_seq0 = th.th_seq0-1;
	    }
	}
	sseq = th.th_seq0;
	t0 = th.th_t0;
	break;
    default:
	retval = 0; 	    
	errpkts++;
	goto done;
    	break;
    }
    /*
     * A data-packet has been received. This is its state:
     * snd holds it control state if any. If snd=NULL the control packet has
     * not received yet or it is just a non-grideye_sender
     */
    *ok = 1; /* ok pkt */
    for (cmsg=CMSG_FIRSTHDR(&msg); cmsg!=NULL; cmsg=CMSG_NXTHDR(&msg,cmsg)) {
	if (cmsg->cmsg_type==IP_TTL) {
	    if (CMSG_DATA(cmsg) !=  NULL){
//			ttl = *(int*)CMSG_DATA(cmsg);
		break;
	    }
	}
    }
#if 0
    if (SEQ_LEQ(i,last))
	fprintf(stderr, "Duplicated or reordered packet %d\n", i);
    else
	last = i;
#endif
    /*
     * Here starts actual tests. Would like this to be more generic,
     * ie easy to add new tests.
     */
    /* Global packet counter */
    pkts++;
    if (pkts == 1) 
	firstpkt = t1;
    lastpkt = t1;
    /* Payload buffer. If no registered sender this is empty */
    if ((cb = cbuf_new()) ==NULL){
	clicon_err(OE_PLUGIN, errno, "cbuf_new");
	goto done;
    }

    /* Here starts 'Application monitoring' ie 'programable behaviour'
     * Only do this if sender is known and if we have received grideye 
     * control packets
     */
    if (snd != NULL){
	/* Problem: three-value return
	 * Fatal error: -1 and quit
	 * Drop: 0: return 0, break
	 * OK: 1 continue
	 */
	if ((retval = echo_application(snd, myname, dpayload, cb, plugins)) < 0)
	    goto done;
	if (retval == 0)
	    goto done;
	retval = -1;
    }
    slen = sizeof(th)+cbuf_len(cb)+1;
    t2 = gettimestamp();

    if (snd)
	th.th_seq1 = snd->s_seq++;
    th.th_t1 = t1;
    th.th_t2 = t2;
    if (encode_twoway(buf, slen, &th, cbuf_get(cb)) < 0)
	goto done;
    /* Simulated loss and duplicate for debugging */
    if (loss && loss == sseq)
	clicon_log(LOG_DEBUG, "Loss %d", sseq);
    else{
	if (send_one_agent(s, msg.msg_name, msg.msg_namelen, buf, slen) < 0)
	    goto done;
    }
    if (duplicate && duplicate==sseq){
	clicon_log(LOG_DEBUG, "Duplicate %d", sseq);
	if (send_one_agent(s, msg.msg_name, msg.msg_namelen, buf, slen) < 0)
	    goto done;
    }
		
    if (debug){
	timersub(&t1, &t0, &dt);
	clicon_log(LOG_DEBUG, "%s seq: %u %lu.%06lu", 
		   __FUNCTION__, sseq, dt.tv_sec, dt.tv_usec);
    }
    retval = 0;
  done:
    clicon_log(LOG_DEBUG, "%s: end %d", __FUNCTION__, retval);
    if (xpayload)
	xml_free(xpayload);
    if (cb)
	cbuf_free(cb);
    return retval;
}

/*! This is signaling: create agent to send to this agent 
 * Send a CURL POST to controller and register (or change) existing agent.
 * @param[in]  url
 * @param[in]  name
 * @param[in]  id
 * @param[in]  proto
 * @param[in]  myaddr        Address, port of locally bound socket
 * @param[in]  info          Onfo about this node/agent
 * @param[in,out] natstate   0:none 1:enabled 2:addr&port defined 3: connected
 * @see nattraversal_udp 
 * XXX: problem with using curl primary_ip in registering server. Eg curl localhost can resolve to
 *      ::1 , 127.0.1.1 or 127.0.0.1 but the server sender can use typically 127.0.0.1
 */
static int
callhome_http(char               *url, 
	      char               *name, 
	      char               *id, 
	      enum grideye_proto  proto,
	      struct sockaddr_in *myaddr,
	      char               *info,
	      int                *natstate)

{
    int    retval = -1;
    cbuf  *cb = NULL;
    cbuf  *ub = NULL;
    char  *getdata = NULL;
    cxobj *xreply = NULL;
    cxobj *x;
    int    udp_sport;
    char  *remoteip = NULL;
    int    haddr; /* nat addr */
    struct sender *snd = NULL; 
    struct sockaddr_in sndaddr = {0,};
    int    i;
    struct plugin *p;
    
    if ((cb = cbuf_new()) == NULL){
      clicon_err(OE_UNIX, errno, "cbuf_new");
      goto done;
    }
    if ((ub = cbuf_new()) == NULL){
      clicon_err(OE_UNIX, errno, "cbuf_new");
      goto done;
    }
    cprintf(cb, "name=%s", name);
    cprintf(cb, "&id=%s", id);
    
    if (myaddr && myaddr->sin_port) /* tcp may have port 0 since agent will connect later */
	cprintf(cb, "&port=%hu", ntohs(myaddr->sin_port));
    cprintf(cb, "&version=%u", GRIDEYE_AGENT_VERSION);
    cprintf(cb, "&proto=%s", grideye_proto2str(proto));
    if (info)
	cprintf(cb, "&info=\"%s\"", info);
    /* Send comma-separated list of plugins */
    cprintf(cb, "&plugins=\"");
    i = 0;
    for (p = plugins; (p->p_api!=NULL); p++){
	if (p->p_disable)
	    continue;
	if (i++)
	    cprintf(cb, ",");
	cprintf(cb, "%s", p->p_name);
    }
    cprintf(cb, "\"");
    cprintf(ub, "%s/api/callhome", url);

    if (url_post(cbuf_get(ub), NULL, NULL, cbuf_get(cb), NULL, 
		 &getdata, &remoteip) < 0)
	goto done;
    /* xml parse reply: here is where we get the port */
    switch (proto){
    case GRIDEYE_PROTO_TCP:
    case GRIDEYE_PROTO_UDP:
	if (getdata==NULL)
	    break;
	clicon_log(LOG_DEBUG, "%s remoteip:%s getdata:%s", __FUNCTION__,
		   remoteip, getdata);
	if (xml_parse_string(getdata, NULL, &xreply) < 0){
	    clicon_log(LOG_WARNING,  "%s: xml parse error: %s", __FUNCTION__, getdata);
	    /* Note this could actually be html, eg broken xml */
	    retval = 0;
	    goto done;
	}
	clicon_log(LOG_DEBUG,  "%s: xml OK", __FUNCTION__);
	if (*natstate > 0 && remoteip && xreply){
	    *natstate = 1;/* if changed sender, natstate may be 2 */
	clicon_log(LOG_DEBUG,  "%s: natstate to 1", __FUNCTION__);
	    sndaddr.sin_family = AF_INET;
#ifdef HAVE_SIN_LEN
	    sndaddr.sin_len = sizeof(sndaddr);
#endif
	    if ((haddr = inet_addr(remoteip)) != -1)
		sndaddr.sin_addr.s_addr = haddr;
	    if ((x = xpath_first(xreply, "grideye/udp_sport")) != NULL){
		if ((udp_sport = atoi(xml_body(x))) != 0){
		    sndaddr.sin_port = htons(udp_sport);
		    *natstate = 2;
		}
	    }
	    else
	    	clicon_log(LOG_DEBUG,  "%s: no udp sport", __FUNCTION__);
	    if (*natstate > 1){
		/* register sender */
		if ((snd = s_find(&sndaddr, sizeof(sndaddr))) == NULL){
		    if ((snd = s_add(&sndaddr, sizeof(sndaddr))) == NULL)
			goto done;
		    /* XXX for TCP do connect */
		    clicon_log(LOG_DEBUG, "grideye_agent: Registered new sender %s:%hu", 
			       inet_ntoa(sndaddr.sin_addr), 
			       ntohs(sndaddr.sin_port));
		    if ((snd->s_name = strdup(name)) == NULL){
			clicon_err(OE_UNIX, errno, "strdup");
			goto done;
		    }
		}
		if (snd->s_xml != NULL)
		    xml_free(snd->s_xml); /* delete old tree */
		snd->s_xml = xreply;
		xreply = NULL;
	    }
	}
	break;
    case GRIDEYE_PROTO_HTTP:
	clicon_log(LOG_DEBUG, "%s getdata:%s", __FUNCTION__, getdata);
	*natstate = 2;
	break;
    default:
      break;
    }
    retval = 0;
 done:
    if (remoteip)
	free(remoteip);
    if (xreply)
	xml_free(xreply);
    if (getdata)
	free(getdata);
    if (ub)
	cbuf_free(ub);
    if (cb)
	cbuf_free(cb);
    return retval;
}

/*! This is for NAT traversal: send udp towards server just to open existing stream 
 * Timeout only when there havent been any packets for some time.
 * @param[in]  s         Socket to send on
 * @param[in]  myaddr    Address, port of locally bound socket
 * @param[in]  sndaddr   Address to send a nat traversal probe packet to.
 * @param[in]  buf       Raw message buffer to re-use
 * @param[in]  len       Length of message buffer buf
 * @param[in]  name      Name of sender/agent
 * @param[in]  eid64str  EID64 string, given or random for this agent
 * @see callhome_http
 */
static int
nattraversal_udp(int                 s, 
		 struct sockaddr_in *myaddr,
		 char               *name,
		 char               *eid64str)
{
    int                retval = -1;
    struct control_hdr ch0;
    int                clen;
    cbuf              *xmlbuf = NULL;
    char               buf[BUFSIZE];
    int                len = BUFSIZE;
    struct sockaddr_in *sndaddr;
    struct sender      *snd;

    if ((snd = s_list) == NULL)
	return 0;
    sndaddr = (struct sockaddr_in *)(snd->s_sname);
    clicon_log(LOG_DEBUG, "%s nat probe address : %s:%u", 
		 __FUNCTION__,
		 inet_ntoa(sndaddr->sin_addr), 
		 ntohs(sndaddr->sin_port));	    
    assert(sndaddr->sin_port);   
    memset(&ch0, 0, sizeof(ch0));
    ch0.ch_ver   = PROTO_VERSION;
    ch0.ch_mtype = MTYPE_CONTROL;
    ch0.ch_tag2  = TWOWAY_TAG;
    if ((xmlbuf = cbuf_new()) == NULL)
	goto done;
    cprintf(xmlbuf, "<grideye><version>%d</version><name>%s</name><E64>%s</E64>", 
	    GRIDEYE_AGENT_VERSION,
	    name,
	    eid64str);
    cprintf(xmlbuf, "</grideye>"); 
    if ((clen = encode_control(buf, len, &ch0, cbuf_get(xmlbuf))) < 0)
	goto done;
    if (send_one_agent(s, 
		       (struct sockaddr*)sndaddr, 
		       sizeof(*sndaddr), 
		       buf, clen) < 0){
	goto done;
    }	
    retval = 0;
 done:
    if (xmlbuf)
	cbuf_free(xmlbuf);
    return retval;
}


/* For linux /proc */
#define PROC_CPUINFO "/proc/cpuinfo"
static int
get_system_info(char **info)
{
    int   retval = -1;
    FILE *f = NULL;
    char  buf[1024];
#ifdef __APPLE__
    struct utsname name;
    if (uname(&name) < 0){
      clicon_err(OE_UNIX, errno, "uname");
      goto done;
    }
    snprintf(buf, 1024, "%s %s", name.sysname, name.release);
    if ((*info = strdup(buf))==NULL){
      clicon_err(OE_UNIX, errno, "strdup");
      goto done;
    }
#else

    char *line;
    char *s;

    if ((f = fopen(PROC_CPUINFO, "r")) == NULL)
	goto done; 
    while ((line = fgets(buf, sizeof(buf), f)) != NULL){
	if ((s = strstr(line, "model name")) == NULL)
	    continue;
	s+=strlen("model name")+3;
	if (s[strlen(s)-1] == '\n')
	    s[strlen(s)-1] = '\0';
	if ((*info = strdup(s))==NULL){
	    clicon_err(OE_UNIX, errno, "strdup");
	    goto done;
	}
	break;
    }
#endif
    retval = 0;
 done:
    if (f != NULL)
	fclose(f);
    return retval;   
}

/*! This is for NAT traversal: connect via tcp to grideye_sender
 * Timeout only when there havent been any packets for some time.
 * @param[in]  s         Socket to send on
 * @param[in]  myaddr    Address, port of locally bound socket
 * @param[in]  sndaddr  Address to send a nat traversal probe packet to.
 * @param[in]  buf       Raw message buffer to re-use
 * @param[in]  len       Length of message buffer buf
 * @param[in]  name      Name of sender/agent
 * @param[in]  eid64str  EID64 string, given or random for this agent
 * @see callhome_http
 */
static int
nattraversal_tcp(int                 s, 
		 struct sockaddr_in *myaddr,
		 char               *name,
		 char               *eid64str,
		 int                *natstate)
{
    int                retval = -1;
    struct control_hdr ch0;
    int                clen;
    cbuf              *xmlbuf = NULL;
    char               buf[BUFSIZE];
    int                len = BUFSIZE;
    struct sockaddr_in *sndaddr;
    struct sender      *snd;

    clicon_log(LOG_DEBUG, "%s", __FUNCTION__);
    if ((snd = s_list) == NULL)
	return 0;
    sndaddr = (struct sockaddr_in *)(snd->s_sname);

    clicon_log(LOG_DEBUG, "%s Trying to connect to : %s:%u", 
		 __FUNCTION__,
		 inet_ntoa(sndaddr->sin_addr), 
		 ntohs(sndaddr->sin_port));	    
    if (connect(s, (struct sockaddr *)sndaddr, sizeof(*sndaddr)) < 0){
	clicon_err(OE_UNIX, errno, "connect");
	goto done;
    }
    clicon_log(LOG_DEBUG, "%s connectected to : %s:%u", 
		 __FUNCTION__,
		 inet_ntoa(sndaddr->sin_addr), 
		 ntohs(sndaddr->sin_port));	    
    memset(&ch0, 0, sizeof(ch0));
    ch0.ch_ver   = PROTO_VERSION;
    ch0.ch_mtype = MTYPE_CONTROL;
    ch0.ch_tag2  = TWOWAY_TAG;
    if ((xmlbuf = cbuf_new()) == NULL)
	goto done;
    cprintf(xmlbuf, "<grideye><version>%d</version><name>%s</name><E64>%s</E64>", 
	    GRIDEYE_AGENT_VERSION,
	    name,
	    eid64str);
    cprintf(xmlbuf, "</grideye>");
    if ((clen = encode_control(buf, len, &ch0, cbuf_get(xmlbuf))) < 0)
	goto done;
    if (send_one_agent(s, NULL, 0, buf, clen) < 0)
	goto done;
    *natstate = 3;
    retval = 0;
 done:
    clicon_log(LOG_DEBUG, "%s retval:%d", 
	       __FUNCTION__, retval);

    if (xmlbuf)
	cbuf_free(xmlbuf);
    return retval;
}

static void 
grideye_sig(int arg)
{
    clicon_log(LOG_NOTICE, "%s: %d", __FUNCTION__, arg);
}

/*! Exit functions either called on sigterm or end of main */
static void 
doexit(int arg)
{
    struct timeval dur;
    void          *handle = NULL;
    struct plugin *p;

    clicon_log(LOG_NOTICE, "%s: %d", __FUNCTION__, arg);
    timersub(&lastpkt, &firstpkt, &dur);

    if (pidfile)
	unlink(pidfile);   
    clicon_log(LOG_NOTICE, "grideye_agent: %s: Terminated: Received %d packets (term) during %ld.%03ld secs", 
	    hostname, pkts, dur.tv_sec, dur.tv_usec/1000);
    if (plugins){
	handle = plugins->p_handle;
/* Cant run exit functions here because we may run in interrupt stack */
	for (p = plugins; (p->p_api!=NULL); p++){
	    if (p->p_filename)
		free(p->p_filename);
	    if (p->p_name)
		free(p->p_name);
	}
	free(plugins);
	plugins = NULL;
	if (handle)
	    dlclose(handle);
    }
    while (s_list != NULL)
	s_rm(s_list);
    exit(0);
}

static int
callhome(int                 s,
	 char               *callhome_url,
	 char               *hostname,
	 char               *userid,
	 enum grideye_proto  proto,
	 int                *natstate,
	 struct sockaddr_in *myaddr,
	 char               *eid64str,
	 char               *info
	 )
{
    int            retval = -1;

    clicon_log(LOG_DEBUG, "%s", __FUNCTION__);
    if (callhome_url && userid){     /* Timeout Send a (call)home message */
	if (callhome_http(callhome_url, 
			  hostname, 
			  userid, 
			  proto, 
			  myaddr,
			  info,
			  natstate) < 0)
	    goto done;
    }
    clicon_log(LOG_DEBUG, "%s natstate:%d", __FUNCTION__, *natstate);
    if ((*natstate) > 1){     /* Timeout Send a (call)home message */
	switch(proto){
	case GRIDEYE_PROTO_TCP:
	    if (nattraversal_tcp(s, 
				 myaddr, 
				 hostname,
				 eid64str,
				 natstate) < 0)
		goto done;
	    break;
	case GRIDEYE_PROTO_UDP:
	    if (nattraversal_udp(s, 
				 myaddr, 
				 hostname,
				 eid64str) < 0)
		goto done;
	    break;
	default:
	    break;
	}
    }
    retval = 0;
 done:
    return retval;
}

static void
usage(char *argv0)
{
    fprintf(stderr, "usage:\t%s [options]*    Receive UDP packets on socket\n"
	    "where options are:\n"
	    "\t-h \t\tHelp text\n" 
	    "\t-D \t\tDebug\n"
    	    "\t-F \t\tRun in foreground and log to stderr\n"
	    "\t-v \t\tPrint version\n" 
	    "\t-q \t\tQuiet\n" 
	    "\t-e <eid64> \tDevice identifier (random if not given)\n" 
	    "\t-t <s> \t\tCallhome timeout in seconds (if idle) (default:%d)\n"
	    "\t-f <filename>\tLog to file\n"
	    "\t-i <ifname>\t(Local) receiving interface name (see -a)\n"
	    "\t-a <host>\t(Local) hostname or IPv4 address to listen to (see -i) \n"
	    "\t-l <port> Local port\n"
	    "\t-W <dir> \tWorking directory for disk i/o (default: %s). Two\n"
	    "\t\t\tfiles will be created, %s and %s\n"
	    "\t-u <url>\tCall home URL. Send if no rx traffic in -t s\n"
	    "\t-I <id>\t\tId to use with -u\n"
	    "\t-N <name>\tName to use in logs and callhome. default is hostname\n"
	    "\t-p udp|tcp|http\tData protocol to use with -u\n"
	    "\t-r \t\tSynthetic reorder of pkt 30\n"
	    "\t-L \t\tSynthetic loss of pkt 20\n"
	    "\t-d \t\tSynthetic duplicate of pkt 40\n"
	    "\t-w [ifname]\tWireless interface\n"
	    "\t-P <dir>\tPlugin directory(default: %s)\n"
	    "\t-z \t\tKill other config daemon and exit\n"
	    "\t-k <pidfile> \tPidfile, default: %s\n",
	    argv0,
	    CALLHOME_DEFAULT,
	    DISKIO_DIR,
	    DISKIO_LARGEFILE,
	    DISKIO_WRITEFILE,
	    PLUGINDIR,
	    GRIDEYE_AGENT_PIDFILE
	    );
    exit(0);
}

int 
main(int   argc, 
     char *argv[])
{
    char               *argv0;
    int                 retval = -1;
    int                 s = -1;
    int                 c;
    struct in_addr      inaddr = {0, };
    unsigned short      localport; /* local port */
    struct sockaddr_in  myaddr = {0, };
    fd_set              fdset;
    int                 callhome_timeout;
    char               *filename;
    FILE               *f;
    uint64_t            eid64;
    char                eid64str[24];
    int                 yes;
    int                 n;
    char               *diskio_dir;
    char               *diskio_largefile = NULL;
    char               *diskio_writefile = NULL;
    char               buf[BUFSIZE];
    int                len = BUFSIZE;
    struct timeval     t1; /* when received */
    int                natstate; /* state: 0:none 1:enabled 2:addr&port defined */
    char              *callhome_url;
    struct timeval     tv;
    struct timeval     trnd;
    int                loss;
    int                reorder;
    int                duplicate;
    char              *userid = NULL;
    enum grideye_proto proto;
    char              *wi = NULL; /* Wireless interface */
    char              *plugin_dir = NULL;
    struct plugin     *p;
    struct grideye_plugin_api_v2 *api;
    int                foreground;
    int                slen;
    int                zap;
    pid_t              pid;
    struct stat        st;
    char              *info = NULL;
    int                errno0;
    int                ok;
    char               pidfile[MAXPATHLEN];

    /* Initialization */
    argv0 = argv[0];
    localport = 0;
    natstate = 1;
    callhome_url = NULL;
    callhome_timeout = CALLHOME_DEFAULT; /* timeout for call home */
    filename = NULL;
    f = NULL;
    gettimeofday(&trnd, NULL);
    srandom(trnd.tv_usec); /* init random */
    eid64 = random();
    eid64 = eid64<<32;
    eid64 |= random();
    yes = 1;
    zap = 0;
    diskio_dir  = DISKIO_DIR;
    loss = 0;
    reorder = 0;
    duplicate = 0;
    plugin_dir = PLUGINDIR;
    plugins = NULL;
    foreground = 0;
    proto = GRIDEYE_PROTO_UDP;
    strncpy(pidfile, GRIDEYE_AGENT_PIDFILE, sizeof(pidfile)-1);

    /* Hostname for logs and callbacks, overwritten by -N */
    if (gethostname(hostname, sizeof(hostname)) < 0) {
	clicon_err(OE_UNIX, errno, "gethostname");
	exit(0);
    }
    clicon_log_init("grideye_agent", LOG_INFO, CLICON_LOG_STDERR); 
    while ((c = getopt(argc, argv, GRIDEYE_AGENT_OPTS)) != -1){
	switch (c) {
	case 'h' : /* help */
	    usage(argv0);
	    break;
	case 'D' : /* debug */
	    debug++;
	    break;
	case 'F' : /* foreground */
	    foreground = 1;
	    break;
	case 'v' : /* version */
	    fprintf(stderr, "Grideye v%s prototype\n", GRIDEYE_VERSION);
	    fprintf(stderr, "%s\n", GRIDEYE_BUILDSTR);
	    exit(0);
	    break;
	case 't' : /* callhome timeout */
	    callhome_timeout = atoi(optarg);
	    break;
	case 'q' : /* be (more) quiet */
	    quiet++;
	    break;
	case 'e' : /* eid */
	    eid64 = atoll(optarg);
	    break;
	case 'f' : /* filename */
	    filename = optarg;
	    break;
	case 'i' : /* interface  (overridden by -a) */
	    if (ifname2addr(optarg, &inaddr) < 0)
		goto done;
	    break;
	case 'a': /* Local address or hostname (overrides -i) */
	    if (host2addr(optarg, &inaddr) < 0) {
		fprintf(stderr, "Invalid address: %s\n", optarg);
		usage(argv0);
	    }
	    break;
	case 'l' : /* local port */
	    localport = atoi(optarg);
	    if (localport <= 0){
		fprintf(stderr, "Invalid local port: %s\n", optarg);
		usage(argv0);
	    }
	    break;
	case 'W':    /* Disk I/O directory */
	    diskio_dir = optarg;
	    break;
	case 'u':    /* URL used with callback */
	    callhome_url = optarg;
	    break;
	case 'I':    /* user id used with callback url */
	    userid = optarg;
	    break;
	case 'N':    /* Name to use with -u and in logs */
	    strncpy(hostname, optarg, sizeof(hostname));
	    hostname[sizeof(hostname) - 1]= '\0';
	    break;
	case 'p':    /* protocol (tcp, udp or http) */
	    if ((proto = grideye_str2proto(optarg)) < 0){
		fprintf(stderr, "Invalid proto: %s\n", optarg);
		usage(argv0);
	    }
	    break;
	case 'r':    /* Synthetic reorder */
	    reorder = 30;
	    break;
	case 'L':    /* Synthetic loss */
	    loss = 20;
	    break;
	case 'd':    /* Synthetic duplicate */
	    duplicate = 40;
	    break;
	case 'w':    /* Wireless interface */
	    wi = optarg;
	    break;
	case 'P':    /* Grideye_agent plugin dir*/
	    plugin_dir = optarg;
	    break;
	case 'z': /* Zap other process */
	    zap++;
	    break;
	case 'k':    /* PID file*/
	    strncpy(pidfile, optarg, sizeof(pidfile)-1);
	    break;
	} /* switch */
    } /* while */
    clicon_log(LOG_DEBUG, "wi:%s", wi);
    /* sensd does not want an 0x%lx but parse_uint64 does */
    snprintf(eid64str, sizeof(eid64str), "0x%" PRIu64, eid64);
    /* Get some system info */
    if (get_system_info(&info) < 0)
	goto done;
    if (pidfile_get(pidfile, &pid) < 0)
	goto done;
    if (zap){
	if (pid && pidfile_zapold(pid) < 0)
	    return -1;
	if (lstat(pidfile, &st) == 0)
	    unlink(pidfile);   
	exit(0); /* OK */
    }
    else{
	if (pid){
	    clicon_err(OE_DEMON, 0, "Daemon already running with pid %d\n(Try killing it with %s -z)", 
		       pid, argv0);
	    return -1; /* goto done deletes pidfile */
	}
    }
    /* After this point we can goto done on error 
     * Here there is either no old process or we have killed it,.. 
     */
    if (lstat(pidfile, &st) == 0)
	unlink(pidfile);   
    /* Daemonize and initiate logging. Note error is initiated here to make
       demonized errors OK. Before this stage, errors are logged on stderr 
       also */
    if (foreground==0){
	clicon_log_init("grideye_agent", debug?LOG_DEBUG:LOG_INFO, CLICON_LOG_SYSLOG);
	if (daemon(0, 0) < 0){
	    fprintf(stderr, "config: daemon");
	    exit(-1);
	}
    }
    /* Write pid-file */
    if ((pid = pidfile_write(pidfile)) <  0)
	goto done; 
    if ((plugins = calloc(1, sizeof(struct plugin))) == NULL){
	clicon_err(OE_UNIX, errno, "calloc");
	goto done;
    }
    /* Load test plugins */
    if (plugin_load_dir(plugin_dir, &plugins) < 0)
	goto done;
    for (p = plugins; (api=p->p_api)!=NULL; p++){
	if (api->gp_setopt_fn){
	    /* XXX rewrite these file/device setopts */
	    if ((slen = snprintf(NULL, 0, "%s/%s", diskio_dir, 
				 DISKIO_WRITEFILE)) <= 0)
		goto done;
	    if ((diskio_writefile = malloc(slen+1)) == NULL)
		goto done;
	    snprintf(diskio_writefile, slen+1, "%s/%s", diskio_dir, 
		     DISKIO_WRITEFILE);

	    if ((slen = snprintf(NULL, 0, "%s/%s", diskio_dir, 
				 DISKIO_LARGEFILE)) <= 0)
		goto done;
	    if ((diskio_largefile = malloc(slen+1)) == NULL)
		goto done;
	    snprintf(diskio_largefile, slen+1, "%s/%s", diskio_dir, 
		     DISKIO_LARGEFILE);
	    if (api->gp_setopt_fn("writefile", diskio_writefile) < 0){
		p->p_disable++;
		clicon_log(LOG_NOTICE, "plugin setopt(writefile):%s",
			   diskio_writefile);
		clicon_log(LOG_NOTICE, "Disable plugin %s: %s", 
			   p->p_filename, strerror(errno));
	    }
	    if (api->gp_setopt_fn("largefile", diskio_largefile) < 0){
		clicon_log(LOG_NOTICE, "plugin setopt(largefile):%s",
			   diskio_largefile);
		clicon_log(LOG_NOTICE, "Disable plugin %s: %s", 
			   p->p_filename, strerror(errno));
	    }
	    if (api->gp_setopt_fn("device", wi) < 0){
		p->p_disable++;
		clicon_log(LOG_NOTICE, "plugin setopt(device):%s",
			   diskio_largefile);
		clicon_log(LOG_NOTICE, "Disable plugin %s: %s", 
			   p->p_filename, strerror(errno));
	    }
	}
    }
    if (0)
	fprintf(stderr, "%s %s\n", diskio_largefile, diskio_writefile);
    if (filename){
	if ((f = fopen(filename, "w")) == NULL){
	    clicon_err(OE_UNIX, errno, "fopen");
	    exit(0);
	}
    }
    set_signal(SIGINT, grideye_sig, NULL);
    set_signal(SIGTERM, grideye_sig, NULL);

    /* Initialize: create/bind socket for tcp/udp */
    switch (proto){
    case GRIDEYE_PROTO_TCP:
	if ((s = socket(AF_INET, SOCK_STREAM, 0)) < 0) {
	    clicon_err(OE_UNIX, errno, "socket");
	    goto done;
	}
	break;
    case GRIDEYE_PROTO_UDP:
	if ((s = socket(AF_INET, SOCK_DGRAM, 0)) < 0) {
	    clicon_err(OE_UNIX, errno, "socket");
	    goto done;
	}
	if (socket_bind_udp(s, 
			    &inaddr, 
			    localport, 
			    &myaddr) < 0)
	    goto done;
	/* From here on use myaddr, not localport/inaddr */
	clicon_log(LOG_NOTICE, "grideye_agent %s Listening to: %s:%hu", 
		   hostname, inet_ntoa(myaddr.sin_addr), ntohs(myaddr.sin_port));
	/* Local socket */
	if (setsockopt(s, SOL_SOCKET, SO_REUSEADDR, &yes, sizeof(int)) < 0){
	    clicon_err(OE_UNIX, errno, "socket");
	    goto done;
	}
#if defined(SOL_IP)
	if(setsockopt(s, SOL_IP, IP_RECVTTL, &yes, sizeof(int))<0){
	    clicon_err(OE_UNIX, errno, "socket");
	    goto done;
	}
#endif
	break;
    case GRIDEYE_PROTO_HTTP:
    default:
	break;
    }
    /* kickstart */
    switch (proto){
    case GRIDEYE_PROTO_TCP:
    case GRIDEYE_PROTO_UDP:
	if (callhome(s, 
		     callhome_url,
		     hostname,
		     userid,
		     proto,
		     &natstate,
		     &myaddr,
		     eid64str,
		     info) < 0)
	    goto done;
	break;
    case GRIDEYE_PROTO_HTTP:
	if (callhome_url && userid)     /* Timeout Send a (call)home message */
	    if (callhome_http(callhome_url, 
			      hostname, 
			      userid, 
			      proto, 
			      NULL,
			      info,
			      &natstate) < 0)
		goto done;
	break;
    default:
      break;
    }
    tv.tv_sec = callhome_timeout;
    for (;;){
	FD_ZERO(&fdset);
	switch (proto){
	case GRIDEYE_PROTO_UDP:
	    FD_SET(s, &fdset);
	    break;
	case GRIDEYE_PROTO_TCP:
	    if (natstate > 2) /* connected */
		FD_SET(s, &fdset); 
	    break;
	case GRIDEYE_PROTO_HTTP:
	default:
	    break;
	}
	//clicon_log(LOG_DEBUG, "Callhome timeout: %d", callhome_timeout;)
	tv.tv_usec = 0;
	n = select(FD_SETSIZE, &fdset, NULL, NULL, &tv);
	/* Consider timeout to be undefined after select() returns. */
	errno0 = errno;
	t1 = gettimestamp();
	if (n == -1) {
	    clicon_err(OE_UNIX, errno0, "select");
	    goto done;
	}
	/* Timeout */
	if (n==0){
	    if (callhome(s, 
			 callhome_url,
			 hostname,
			 userid,
			 proto,
			 &natstate,
			 &myaddr,
			 eid64str,
			 info) < 0)
		goto done;
	    tv.tv_sec = callhome_timeout;
	}
	/* Check sockets */
	switch(proto){
	case GRIDEYE_PROTO_TCP:
	case GRIDEYE_PROTO_UDP:
	    if (FD_ISSET(s, &fdset)){  /* udp. can this work for tcp? */
		ok = 0;
		if (echo_packet(s, 
				t1,
				buf, 
				len, 
				eid64str, 
				loss,
				reorder,
				duplicate,
				wi,
				plugins,
				hostname,
				&ok) < 0)
		    goto done;
		if (ok)
		    tv.tv_sec = callhome_timeout;
	    }
	    break;
	case GRIDEYE_PROTO_HTTP: /* Eeeh need timer */
	    clicon_log(LOG_DEBUG, "Send curl Sample");
	    break;
	default:
	  break;
	}
    } /* for */
    retval = 0;
 done:
    if (s != -1)
	close(s);
#if 0
    if (callhome_url && name && userid){     /* Timeout Send a (call)home message */
	if (callhome_http(callhome_url, name, userid, proto, localport, info,
			  &natstate, 1) < 0)
	    goto done;
#endif
	if (diskio_writefile)
	    free(diskio_writefile);
	if (diskio_largefile)
	    free(diskio_largefile);
    doexit(0);
    return(retval);
}

