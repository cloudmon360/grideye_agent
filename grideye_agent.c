/*
  Copyright (C) 2015-2018 Olof Hagsand

  This file is part of GRIDEYE.

  GRIDEYE is free software; you can redistribute it and/or modify
  it under the terms of the GNU General Public License as published by
  the Free Software Foundation; either version 3 of the License, or
  (at your option) any later version.

  GRIDEYE is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  GNU General Public License for more details.

  You should have received a copy of the GNU General Public License
  along with GRIDEYE; see the file LICENSE.  If not, see
  <http://www.gnu.org/licenses/>.
*/

#define _GNU_SOURCE /* This is to enable O_DIRECT */
#if defined(__i386__)
#define _FILE_OFFSET_BITS 64
#endif

#include <stdio.h>
#include <stdlib.h>
#include <inttypes.h>
#include <string.h>
#include <signal.h>
#include <sys/param.h>
#include <sys/socket.h>
#include <sys/uio.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <netdb.h>
#include <unistd.h>
#include <time.h>
#include <assert.h>
#include <dirent.h>
#include <fcntl.h>
#include <dlfcn.h>
#include <errno.h>
#include <sys/time.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <sys/ioctl.h>
#include <syslog.h>
#include <net/if.h>
#include <math.h>
#include <curl/curl.h>
#include <sys/utsname.h>

#ifdef HAVE_LINUX_SOCKIOS_H
#include <linux/sockios.h> /* Dont remove: SIOCGIFADDR will be undefined below */
#elif defined(HAVE_SYS_SOCKIO_H)
#include <sys/sockio.h> /* Dont remove: SIOCGIFADDR will be undefined below */
#endif

/* For Python plugin support */
#include <Python.h>

#include <cligen/cligen.h>     /* cbuf */
#include <clixon/clixon.h>     /* xml, xpath, log, err */

#include "grideye_agent.h"     /* lib */
#include "grideye_plugin.h" /* plugin C API */

/*
 * Global variables generated by Makefile
 */
extern const char GRIDEYE_BUILDSTR[];
extern const char GRIDEYE_VERSION[];

#define	SEQ_LT(a,b)	((int)((a)-(b)) < 0)
#define	SEQ_LEQ(a,b)	((int)((a)-(b)) <= 0)
#define	SEQ_GT(a,b)	((int)((a)-(b)) > 0)
#define	SEQ_GEQ(a,b)	((int)((a)-(b)) >= 0)

/* Protocol agent version. Bundle with plugin API version
 * I.e. one agent version supports one plugin version
 * But one controller must support multiple agent versions
 *
 * Version 2:
 *   New more capable test and plugin protocol
 * Version 3:
 *   Send callhome as restconf clixon RPC instead of just HTTP
 *   HTTP initiated from agent as control protocol option
 */
#define GRIDEYE_AGENT_VERSION 3

/* Set this to a file (prefix) and this will dump incoming binary messages */
//#define DUMPMSGFILE "grideyedump"

#define DISKIO_DIR        "/var/tmp"  /* in current dir */
#define DISKIO_LARGEFILE  "GRIDEYE_LARGEFILE" /* To use for random read ops */
#define DISKIO_WRITEFILE  "GRIDEYE_WRITEFILE" /* To use for trunc writing */
#define BUFSIZE           8*1024

#define GRIDEYE_AGENT_PIDFILE "/var/run/grideye_agent.pidfile"

/* This timeout may interfer with network timeout. It should be well above
 * interval setting (eg yang sender->round->interval
 * but may also trigger if the probe is out of reach for a period of time
 * So: either no traffic reaching the probe, or "wrong" traffic reaching,
 * Wrong being for example a new sender (the old is dead).
 */
#define CALLHOME_DEFAULT  20 /* seconds */

/* CURL post timeout - wait for remote end to answer in seconds */
#define CURL_TIMEOUT_DEFAULT 60 

/* Wireless file to read status from */
#define PROC_NET_WIRELESS "/proc/net/wireless"

/* Run with american fuzzy lop http://lcamtuf.coredump.cx/afl 
 * Only runs with -p http and replaces curl with stdin/stdout
 */
#undef FUZZ

/* By default, this is where grideye_agent looks for plugins
 * This is normally set in configure/Makefile as $exec_prefix/lib/grideye
 * eg /usr/local/lib/grideye.
 */
#ifndef PLUGINDIR
#define PLUGINDIR "/usr/local/lib/grideye"
#endif

#define GRIDEYE_PLUGIN_PYTHON 0x50595448

#ifdef FUZZ
#define GRIDEYE_AGENT_OPTS "hDFvtqe:f:i:a:l:W:u:I:N:p:rLdw:P:zk:sT:Z"
#else
#define GRIDEYE_AGENT_OPTS "hDFvtqe:f:i:a:l:W:u:I:N:p:rLdw:P:zk:sT:"
#endif

/*
 * Local types
 */
struct sender {
    struct sender  *s_next;    /* linked list */
    void           *s_sname;   /* socket name, eg sockaddr */
    socklen_t       s_snamelen;
    char           *s_name;    /* name given by sender */
    uint32_t        s_seq;
    cxobj          *s_xml;     /* XML control tree with config info received in
			        * most recdetn callhome reply */
};

/*
 * Types buffer for curl
 */
struct curlbuf{
    size_t b_len;
    char  *b_buf;
};

/* Info of a plugin. Make a vector of these for all plugins */
struct plugin{
    void                         *p_handle;
    int                           p_version;
    char                         *p_filename; /* Actual filename */
    char                         *p_name;     /* Name corresponds to yang spec */
    int                           p_disable; /* something failed */
    struct grideye_plugin_api *p_api;
};

/*
 * Local variables
 */
static struct sender *s_list = NULL;
/* XXX: should be moved as doexit code is moved */
static char hostname[128] = {0,};/* name of this host, -N or gethostname */
static int  pkts = 0;		 /* packets received counter */
static int  errpkts = 0;	 /* dropped packets received counter */
static int  nr_nobufs = 0;       /* global variable to log of buf overflows */
struct timeval firstpkt, lastpkt;
static int     quiet = 0;
static struct plugin *plugins = NULL;
static char    *pidfile = GRIDEYE_AGENT_PIDFILE;
static char *plugin_dir = NULL;
static int ssl_verifypeer = 0;

#ifdef FUZZ
/* AFL fuzzing simulation */
static int fuzz = 0;
#endif

/*
 *! Return number of plugins in plugins vector. This is one less than vectorlen
 */
static int
plugins_len(struct plugin *plugins)
{
    int            i=0;
    struct plugin *p;

    i = 0;
    for (p = plugins; p->p_api!=NULL; p++, i++);
    return i;
}

/*! helper function */
static struct plugin *
plugin_find(char *name)
{
    struct plugin *p;

    for (p = plugins; p&&p->p_api!=NULL; p++)
	if (strcmp(p->p_name, name) == 0)
	    return p;

    return NULL;
}

/*
 *! Convert value of a Python object to a char array
 */
static char
*grideye_pyobj_to_char(PyObject *pyobj)
{
	char *cstr;
	PyObject *tmpstr;

	// Make sure we have a string object
	if (!strcmp((char *)Py_TYPE(pyobj), "str"))
	    goto fail;

	// In Python 3 all strings are unicode
	if ((tmpstr = PyUnicode_AsEncodedString(pyobj, "utf-8", "")) == NULL)
	    goto fail;

	if ((cstr = PyBytes_AS_STRING(tmpstr)) == NULL)
	    goto fail;

	return cstr;

fail:
	return NULL;
}

/*
 *! Convert Python object to integer
 */
static unsigned long
grideye_pyobj_to_long(PyObject *pyobj)
{
	unsigned long ret;
	static unsigned long long_max = 0xFFFFFFFF;

	// Make sure we have an integer
	ret = PyLong_AsUnsignedLong(pyobj);

	if (ret == -1 || ret > long_max)
		goto fail;

	return ret;

fail:
	return -1;
}

/*
 *!
 */
static char
*grideye_call_method(char *name,
		     char *method,
		     char *argstr)
{
    PyObject *pymethod;
    PyObject *pyargs;
    PyObject *pyvalue;
    PyObject *pyretval;
    PyObject *pyname;
    PyObject *pymodule;

    char     *outstr;
    char     *syscmd = NULL;
    char     *modulename = NULL;

    int      modulelen = 0;
    int      syscmdlen = 0;

    if (argstr == NULL)
	    argstr = "";

    if ((modulelen = snprintf(NULL, 0, "grideye_%s", name)) <= 0)
	goto fail;

    if ((syscmdlen = snprintf(NULL,
			      0,
			      "sys.path.append(\"%s\")",
			      plugin_dir)) <= 0)
	goto fail;

    if ((modulename = calloc(modulelen + 1, sizeof(char))) == NULL) {
	clicon_err(OE_UNIX, errno, "calloc");
	goto fail;
    }

    if ((syscmd = calloc(syscmdlen + 1, sizeof(char))) == NULL) {
	clicon_err(OE_UNIX, errno, "calloc");
	goto fail;
    }

    if (snprintf(modulename, modulelen + 1, "grideye_%s", name) <= 0)
	goto fail;

    if (snprintf(syscmd, syscmdlen + 1,
		 "sys.path.append(\"%s\")",
		 plugin_dir) <= 0)
	goto fail;

    Py_Initialize();

    PyRun_SimpleString("import sys");
    PyRun_SimpleString(syscmd);

    if (syscmd)
	free(syscmd);

    pyname = PyUnicode_DecodeFSDefault(modulename);
    pymodule = PyImport_Import(pyname);

    Py_DECREF(pyname);

    if (pymodule == NULL) {
	clicon_log(LOG_ERR, "Failed to load Python module %s method %s", modulename, method);
	goto fail;
    }

    if (modulename)
	free(modulename);

    pymethod = PyObject_GetAttrString(pymodule, method);
    if (!pymethod || !PyCallable_Check(pymethod)) {
	clicon_log(LOG_ERR, "Method %s is not callable", PLUGIN_INIT_FN);
	goto fail;
    }

    Py_DECREF(pymodule);

    pyargs = PyTuple_New(1);
    pyvalue = PyBytes_FromString(argstr);

    PyTuple_SetItem(pyargs, 0, pyvalue);

    Py_DECREF(pyvalue);

    if ((pyretval = PyObject_CallObject(pymethod, pyargs)) == NULL) {
	goto fail;
    }

    Py_DECREF(pyargs);
    Py_DECREF(pymethod);

    if (PyList_Check(pyretval) != 1 || PyList_Size(pyretval) != 1) {
	goto fail;
    }

    outstr = strdup(grideye_pyobj_to_char(PyList_GetItem(pyretval, 0)));

    Py_DECREF(pyretval);

    // Py_Finalize();

    return outstr;

fail:
    Py_Finalize();

    return NULL;
}

/*
 * Load a Python plugin.
 */
static int
grideye_plugin_load_py(void *handle,
		       char *name,
		       char *filename,
		       struct plugin *plugins[])
{
    struct grideye_plugin_api *api = NULL;
    int                       len = 0;
    int                       retval = 0;
    char                      *syscmd = NULL;
    char                      *modulename = NULL;
    int                       syscmdlen = 0;
    int                       modulelen = 0;

    // Python objects
    PyObject                  *pyname;
    PyObject                  *pymodule;
    PyObject                  *pyvalue;
    PyObject                  *pyfunc;
    PyObject                  *pyretval;
    PyObject                  *pyargs;

    int                       gp_version = 0;
    int                       gp_magic = 0;

    modulename = strdup(name);
    modulelen = strlen(modulename);
    modulename[modulelen - 3] = '\0';

    if ((syscmdlen = snprintf(NULL,
			      0,
			      "sys.path.append(\"%s\")",
			      plugin_dir)) <= 0)
	goto fail;

    if ((syscmd = calloc(syscmdlen + 1, sizeof(char))) == NULL) {
	clicon_err(OE_UNIX, errno, "calloc");
	goto fail;
    }

    if ((snprintf(syscmd,
		  syscmdlen + 1,
		  "sys.path.append(\"%s\")",
		  plugin_dir)) <= 0) {
	goto fail;
    }


    Py_Initialize();
    PyRun_SimpleString("import sys");
    PyRun_SimpleString(syscmd);

    if (syscmd)
	free(syscmd);

    pyname = PyUnicode_DecodeFSDefault(modulename);

    if ((pymodule = PyImport_Import(pyname)) == NULL) {
	clicon_log(LOG_ERR, "Failed to load Python module %s method %s", modulename, PLUGIN_INIT_FN);
	goto fail;
    }

    if (modulename)
	free(modulename);

    Py_DECREF(pyname);

    pyfunc = PyObject_GetAttrString(pymodule, PLUGIN_INIT_FN);
    if (!pyfunc || !PyCallable_Check(pyfunc)) {
		clicon_log(LOG_ERR,
			   "Function %s is not callable",
			   PLUGIN_INIT_FN);
		goto fail;
    }

    Py_DECREF(pymodule);

    pyargs = PyTuple_New(1);
    pyvalue = PyLong_FromLong(GRIDEYE_PLUGIN_VERSION);

    PyTuple_SetItem(pyargs, 0, pyvalue);

    Py_DECREF(pyvalue);

    if ((pyretval = PyObject_CallObject(pyfunc, pyargs)) == NULL)
		goto fail;

    Py_DECREF(pyargs);

    if (PyList_Check(pyretval) != 1 || PyList_Size(pyretval) != 9) {
		goto fail;
    }

    if ((gp_version = grideye_pyobj_to_long(PyList_GetItem(pyretval, 0)))
	!= GRIDEYE_PLUGIN_VERSION) {
	    clicon_log(LOG_NOTICE,
		       "grideye_agent: Disabling %s, wrong version",
		       gp_version);
	    goto fail;
    }

    if ((api = calloc(1, sizeof(struct grideye_plugin_api))) == NULL)
	clicon_err(OE_UNIX, errno, "calloc");

    if ((gp_magic = grideye_pyobj_to_long(PyList_GetItem(pyretval, 1)))
	!= GRIDEYE_PLUGIN_MAGIC) {
	    clicon_log(LOG_NOTICE,
		       "grideye_agent: Disabling %s, wrong magic",
		       gp_magic);
	    goto fail;
    }

    api->gp_version = gp_version;
    api->gp_name = grideye_pyobj_to_char(PyList_GetItem(pyretval, 2));
    api->gp_input_format = grideye_pyobj_to_char(PyList_GetItem(pyretval, 3));
    api->gp_output_format = grideye_pyobj_to_char(PyList_GetItem(pyretval, 4));
    api->gp_getopt_fn = (grideye_plugin_getopt_t *)grideye_pyobj_to_char(PyList_GetItem(pyretval, 5));
    api->gp_setopt_fn = (grideye_plugin_setopt_t *)grideye_pyobj_to_char(PyList_GetItem(pyretval, 6));
    api->gp_test_fn = (grideye_plugin_test_t *)grideye_pyobj_to_char(PyList_GetItem(pyretval, 7));
    api->gp_exit_fn = (grideye_plugin_exit_t *)grideye_pyobj_to_char(PyList_GetItem(pyretval, 8));

    /* Make it possible to distinguish between regular plugins and py-plugins */
    api->gp_magic = (gp_magic & GRIDEYE_PLUGIN_PYTHON);

    len = plugins_len(*plugins);
    if ((*plugins = realloc(*plugins, (len+2)*sizeof(struct plugin))) == NULL){
	clicon_err(OE_UNIX, errno, "grideye_agent: realloc failed");
	goto fail;
    }

    memcpy(&(*plugins)[len+1], &(*plugins)[len], sizeof(struct plugin));
    (*plugins)[len].p_handle = handle;

    if (((*plugins)[len].p_filename = strdup(name)) == NULL){
	clicon_err(OE_UNIX, errno, "grideye_agent: strdup failed");
	goto fail;
    }

    /* Plugin name should be read for plugin itself, but use filename - ext */
    if (((*plugins)[len].p_name = strdup(api->gp_name)) == NULL){
	clicon_err(OE_UNIX, errno, "grideye_agent: strdup failed");
	goto fail;
    }

    (*plugins)[len].p_api = api;

    Py_Finalize();

    retval = 1;

 done:
    return retval;

 fail:
    retval = 1;
    goto done;
}

/*! Load a specific plugin, call its init function and add it to plugins list
 * If init function fails (not found, wrong version, etc) print a log and dont
 * add it.
 */
static int
grideye_plugin_load_so(void       *handle,
		    char          *name,
		    char          *filename,
		    struct plugin *plugins[]
		    )
{
    int                           retval = -1;
    char                          *dlerrcode;
    grideye_plugin_init_t         *initfun;
    struct grideye_plugin_api     *api = NULL;
    int                           len;

    /* Try v2 */
    initfun = dlsym(handle, PLUGIN_INIT_FN);
    if ((dlerrcode = (char*)dlerror()) != NULL) {
	clicon_log(LOG_DEBUG, "grideye_agent: %s Skipping %s", __FUNCTION__, dlerrcode);
	goto fail;
    }
    if ((api = initfun(GRIDEYE_PLUGIN_VERSION)) == NULL) {
	clicon_log(LOG_DEBUG, "grideye_agent: %s: failed when running init function %s: %s",
		   filename, PLUGIN_INIT_FN, errno?strerror(errno):"");
	clicon_log(LOG_NOTICE, "grideye_agent: Plugin: Disabling %s (could not start plugin)", name);
	goto fail;
    }
    if (api->gp_version != GRIDEYE_PLUGIN_VERSION){
	clicon_log(LOG_WARNING, "grideye_agent: Plugin: %s unexpected version number: %d",
		   name, api->gp_version);
	goto fail;
    }
    if (api->gp_magic != GRIDEYE_PLUGIN_MAGIC){
	clicon_log(LOG_WARNING, "grideye_agent: Plugin: %s wrong plugin magic number: %x",
		   name, api->gp_magic);
	goto fail;
    }
    len = plugins_len(*plugins);
    if ((*plugins = realloc(*plugins, (len+2)*sizeof(struct plugin))) == NULL){
	clicon_err(OE_UNIX, errno, "grideye_agent: realloc failed");
	goto done;
    }

    memcpy(&(*plugins)[len+1], &(*plugins)[len], sizeof(struct plugin));
    (*plugins)[len].p_handle = handle;

    if (((*plugins)[len].p_filename = strdup(name)) == NULL){
	clicon_err(OE_UNIX, errno, "grideye_agent: strdup failed");
	goto done;
    }

    /* Plugin name should be read for plugin itself, but use filename - ext */
    if (((*plugins)[len].p_name = strdup(api->gp_name)) == NULL){
	clicon_err(OE_UNIX, errno, "grideye_agent: strdup failed");
	goto done;
    }

    (*plugins)[len].p_api = api;

    clicon_log(LOG_NOTICE, "grideye_agent: Plugin: Loading %s", name);
    clicon_log(LOG_DEBUG, "grideye_agent: Plugin: Loading %s from %s", name, filename);

    retval = 0;
 done:
    if (retval < 0)
	dlclose(handle);
    return retval;
 fail: /* plugin load failed, continue */
    retval = 0;
    goto done;
}

/*! Load grideye agent plugins from directory, call init and return handles in vector
 * @param[in]  dir      name of directory where grideye .so plugins reside
 * @param[out] plugins  Null-terminated vector of plugin handles.
 */
static int
plugin_load_dir(char          *dir,
		struct plugin *plugins[])
{
    int            retval = -1;
    DIR           *dirp = NULL;
    struct dirent  dent;
    struct dirent *dresp;
    void          *handle = NULL;
    int            res;
    char          *name;
    int            off_so;
    int            off_py;
    char          *filename = NULL;
    int            len;

    if ((dirp = opendir(dir)) == NULL) {
	clicon_err(OE_PLUGIN, errno, "opendir(%s)", dir);
	if (errno == ENOENT)
	    fprintf(stderr, "No grideye_agent test .so plugins found in %s\n",
		    dir);
	goto done;
    }
    /*
     * dirent->d_name is name of directory entry, if dresp is NULL the iteration
     * is done
     */
   for (res = readdir_r(dirp, &dent, &dresp);
	dresp;
	res = readdir_r (dirp, &dent, &dresp)){
       if (res != 0) {
	   clicon_err(OE_UNIX, errno, "readdir");
	   goto done;
       }
       /* match .so */
       name = dent.d_name;
       off_so = strlen(name)-5;
       off_py = strlen(name) - 3;

       if ((off_so <= 0 || strcmp(".so.1", name + off_so) != 0) && (off_py <= 0 || strcmp(".py", name + off_py) != 0))
	   continue;
       len = strlen(dir)+1+strlen(name)+1;
       if ((filename = malloc(len)) == NULL){
	   clicon_err(OE_UNIX, errno, "malloc");
	   goto done;
       }

       snprintf(filename, len, "%s/%s", dir, name);

       if (strcmp(".so.1", name + off_so) == 0) {
	   dlerror();    /* Clear any existing error */
	   if ((handle = dlopen(filename, RTLD_NOW)) == NULL) {
	       clicon_err(OE_UNIX, 0, "dlopen: %s", (char*)dlerror());
	       goto done;
	   }

	   if (grideye_plugin_load_so(handle, name, filename, plugins) < 0){
	       free(filename);
	       goto done;
	   }
       } else if (strcmp(".py", name + off_py) == 0) {
	   /* Python plugin */
	   if (grideye_plugin_load_py(handle, name, filename, plugins) < 0) {
	       clicon_log(LOG_NOTICE, "grideye_agent: Plugin: Disabling %s",
			  basename(filename));
	       free(filename);
	       goto done;
	   } else {
	       clicon_log(LOG_NOTICE, "grideye_agent: Plugin: Loading %s",
			  basename(filename));
	   }
       }

       free(filename);
   }
    retval = 0;
 done:
    if (dirp)
	closedir(dirp);
    return retval;
}

#ifdef notyet
static int
plugin_unload (void)
{
    int   retval = -1;

    dlerror();    /* Clear any existing error */
    if (dlclose(plg->p_handle) != 0) {
	clicon_err(OE_PLUGIN, errno, "dlclose");
	goto done;
    }
    retval = 0;
 done:
    return retval;
}
#endif /* notyet */

/*! Get (reply) data from server
 */
static size_t
curl_get_cb(void  *ptr,
	    size_t size,
	    size_t nmemb,
	    void  *userdata)
{
    struct curlbuf *buf = (struct curlbuf *)userdata;
    int len;

    len = size*nmemb;
    if ((buf->b_buf = realloc(buf->b_buf, buf->b_len+len+1)) == NULL)
	return 0;
    memcpy(buf->b_buf+buf->b_len, ptr, len);
    buf->b_len += len;
    buf->b_buf[buf->b_len] = '\0';
    //    fprintf(stderr, "%s: %s\n", __FUNCTION__, buf->b_buf);
    return len;
}

/*! Send a curl POST request
 * @param[in]  url      URL - where to send post request to
 * @param[in]  putdata  Data to post
 * @param[in]  header   If set, send as header, eg "Content-Type: application/yang-data+xml"
 * @param[in]  timeout  Curl post request timeout in seconds
 * @param[out] getdata  Pointer to return data, if given, free with malloc
 * @param[out] remoteip Pointer remote IP address in string format
 * @retval    -2   fatal error
 * @retval    -1   non fatal error. Log error and try again
 * @retval     0   expect set but did not expected return or other non-fatal error
 * @retval     1   ok
 * Note: Code taken from grideye
 * Note: curl_easy_perform blocks
 * Note: New handle is created every time, the handle can be re-used for better TCP performance
 */
static int
url_post(char *url,
	 char *putdata,
	 char *header,
	 char *expect,
	 int   timeout,
	 char **getdata,
	 char **remoteip)
{
    CURL      *curl = NULL;
    char      *err = NULL;
    int        retval = -2;
    cxobj     *xr = NULL; /* reply xml */
    struct curlbuf cb = {0, };
    CURLcode   errcode;
    char      *ip = NULL;
    struct curl_slist *list = NULL;

#ifdef FUZZ
    if (fuzz){
      char *s;
      int   len=10*1024;

      if ((*getdata = malloc(len))== NULL){
	clicon_err(OE_PLUGIN, errno, "malloc");
	goto done;
      }
      fprintf(stderr, "%s\n", putdata);
      /* Help text for manual fuzzing */
      fprintf(stdout, "FUZZ:"); fflush(stdout);
      errno = 0;
      if ((s=fgets(*getdata, len, stdin)) == NULL){
	  if (feof(stdin))
	      exit(0);
	  clicon_err(OE_PLUGIN, errno, "fgets: %d", errno);
	  goto done;
      }
      if (s && strlen(s) && s[0]=='q') /* termination criteria */
	exit(0);
      //      fprintf(stdout, "\nGOT:%s", s); fflush(stdout);
      return 0;
    }
#endif /* FUZZ */
    /* Try it with  curl -X PUT -d '*/
    clicon_debug(1,  "%s:  curl -X POST -d '%s' %s",
	       __FUNCTION__, putdata, url);

    /* Set up curl for doing the communication with the controller */
    if ((curl = curl_easy_init()) == NULL) {
	clicon_err(OE_PLUGIN, errno, "curl_easy_init");
	goto done;
    }
    if ((err = malloc(CURL_ERROR_SIZE)) == NULL) {
	clicon_err(OE_UNIX, errno, "malloc");
	goto done;
    }
    memset(err,0,CURL_ERROR_SIZE);
    curl_easy_setopt(curl, CURLOPT_URL, url);
    curl_easy_setopt(curl, CURLOPT_ERRORBUFFER, err);
    curl_easy_setopt(curl, CURLOPT_WRITEFUNCTION, curl_get_cb);
    curl_easy_setopt(curl, CURLOPT_WRITEDATA, &cb);
    curl_easy_setopt(curl, CURLOPT_POST, 1);
    curl_easy_setopt(curl, CURLOPT_POSTFIELDS, putdata);
    curl_easy_setopt(curl, CURLOPT_POSTFIELDSIZE, strlen(putdata));
    /* XXX:
     * If you want to connect to a site who isn't using a certificate that is
     * signed by one of the certs in the CA bundle you have, you can skip the
     * verification of the server's certificate. This makes the connection
     * A LOT LESS SECURE.
     */

    if (ssl_verifypeer > 0)
	curl_easy_setopt(curl, CURLOPT_SSL_VERIFYPEER, 0L);
    if (ssl_verifypeer > 1)
	curl_easy_setopt(curl, CURLOPT_SSL_VERIFYHOST, 0L);
    if (debug>1)
	curl_easy_setopt(curl, CURLOPT_VERBOSE, 1);
    if (header){
	list = curl_slist_append(list, header);
	curl_easy_setopt(curl, CURLOPT_HTTPHEADER, list);
    }

    curl_easy_setopt(curl, CURLOPT_TIMEOUT, timeout); /* Curl timeout */

    errcode = curl_easy_perform(curl);
    switch (errcode){
    case CURLE_COULDNT_RESOLVE_HOST:
    case CURLE_OPERATION_TIMEDOUT:
    case CURLE_COULDNT_CONNECT:
	clicon_log(LOG_WARNING, "%s: %s", url, curl_easy_strerror(errcode));
	retval = -1; /* non-fatal */
	goto done;
	break;
    case CURLE_OK:
	clicon_debug(1, "%s: OK", url);
	break;
    default:
	clicon_err(OE_UNIX, 0, "curl_easy_perform: %s %s errcode:%d",
		   curl_easy_strerror(errcode), err, errcode);
    }
    if (remoteip &&
	curl_easy_getinfo(curl, CURLINFO_PRIMARY_IP, &ip) == CURLE_OK)
	if ((*remoteip = strdup(ip)) == NULL){
	    clicon_err(OE_UNIX, errno, "strdup");
	    goto done;
	}

    if (expect){
	if (cb.b_buf == NULL){
	    clicon_err(OE_PLUGIN, 0, "%s: no match", __FUNCTION__);
	    retval = 0;
	    goto done;
	} else {
	    clicon_debug(1,  "%s: reply:%s", __FUNCTION__, cb.b_buf);
	    if (xml_parse_string(cb.b_buf, NULL, &xr) < 0){
		clicon_log(LOG_DEBUG,  "%s: %s", __FUNCTION__, cb.b_buf);
		goto done;
	    }
	    if (xpath_first(xr, expect) == NULL){
		clicon_err(OE_PLUGIN, 0, "%s: no match", __FUNCTION__);
		retval = 0;
		goto done;
	    }
	}
    }
    if (getdata && cb.b_buf){
	*getdata = cb.b_buf;
	clicon_debug(1, "%s: getdata:%s", __FUNCTION__, *getdata);
	cb.b_buf = NULL;
    }
    retval = 1;
  done:
    clicon_debug(1, "%s: retval:%d", __FUNCTION__, retval);
    if (list)
	curl_slist_free_all(list);
    if (err)
	free(err);
    if (xr)
	xml_free(xr);
    if (cb.b_buf)
	free(cb.b_buf);
    if (curl)
	curl_easy_cleanup(curl);   /* cleanup */
    return retval;
}

static int
s_rm(struct sender *s)
{
    struct sender   *c;
    struct sender  **s_prev;

    s_prev = &s_list;
    for (c = *s_prev; c; c = c->s_next){
	if (c == s){
	    if (s->s_sname)
		free(s->s_sname);
	    if (s->s_xml)
		xml_free(s->s_xml);
	    if (s->s_name)
		free(s->s_name);
	    *s_prev = c->s_next;
	    free(s);
	    break;
	}
	s_prev = &c->s_next;
    }
    return 0;
}

/*! Register a sender, lock enum and source from this sender
 */
static struct sender *
s_add(void      *sname,
      socklen_t  snamelen)

{
    struct sender   *s = NULL;

    if ((s = (struct sender *)malloc(sizeof(*s))) == NULL){
	clicon_err(OE_UNIX, errno, "malloc");
	goto done;
    }
    memset(s, 0, sizeof(*s));
    s->s_snamelen = snamelen;
    if ((s->s_sname = malloc(snamelen)) == NULL){
	clicon_err(OE_UNIX, errno, "malloc");
	goto done;
    }
    memcpy(s->s_sname, sname, snamelen);
    /* Always remove s_list to ensure single sender only */
    if (s_list)
	s_rm(s_list);
    s->s_next = s_list;
    s_list = s;
 done:
    return s;
}

static struct sender *
s_find(void      *sname,
       socklen_t  snamelen)
{
    struct sender *s;

    for (s = s_list; s; s = s->s_next)
	if (s->s_snamelen == snamelen &&
	    memcmp(sname, s->s_sname, snamelen)==0)
	    return s;
    return NULL;
}

/*
 * Format of sendbuf:
 * sequence:32
 * eid64:64
 * timeval:64
 */
static int
send_one_agent(int              s,
	       struct sockaddr *addr,
	       int              addrlen,
	       char            *buf,
	       int              len)
{
    int retval = -1;

    if (sendto(s, buf, len, 0x0, addr, addrlen) < 0){
	switch (errno){
	case ENOBUFS: /* try again if ifq is empty */
	    nr_nobufs++;
	    clicon_log(LOG_WARNING,  "sendto %s %s", __FUNCTION__, strerror(errno));
	    return 0;
	    break;
	case ENETUNREACH: /* try again */
	    clicon_log(LOG_WARNING,  "sendto %s %s", __FUNCTION__, strerror(errno));
	    return 0;
	    break;
	default:
	    clicon_err(OE_UNIX, errno, "sendto");
	    goto done;
	}
    }
    retval = 0;
 done:
    return retval;
}

/*! Received grideye data packet. Make application emulation
 * @param[in]  snd     Sender of received data packet
 * @param[in]  payload String payload in data packet
 * @retval -1  Fatal error
 * @retval  0  Error in packet, drop and continue
 * @retval  1  OK
 */
static int
echo_application(struct sender *snd,
		 char          *myname,
		 char          *payload,
		 cbuf          *cb,
		 struct plugin  plugins[])
{
    int                retval = -1;
    uint64_t          *v = NULL;
    int64_t           *vi = NULL;
    int                i;
    struct plugin     *p;
    struct grideye_plugin_api *api;
    char              *argstr;
    char              *pstr;
    int                pret;
    char              *str = NULL;
    cxobj             *xt = NULL;
    cxobj             *x;
    cxobj             *xp;
    char              *xb;
    cxobj            **xvec = NULL;
    size_t             xlen;

    clicon_log(LOG_DEBUG, "grideye_agent: %s payload:%s", __FUNCTION__, payload);
    if (snd->s_xml == NULL){ /* <grideye> */
	clicon_log(LOG_WARNING, "%s: Expected xml template when receiving data",
		   __FUNCTION__);
	retval = 0; 	    /* sanity check failed, just continue */
	errpkts++;
	goto done;
    }
    /* Look at payload in data packets:
     * <grideye><version>2</version><name>a1</name><plugin><name>p1</name><param>12</param><param>www.youtube.com</param></plugin><plugin>p2</plugin></grideye> 
     * and decompress
     */
    if (payload){
	/* parse incoming payload XML */
	if (json_parse_str(payload, &xt) < 0)
	    goto done;
	/* Check version */
	if ((x = xpath_first(xt, "grideye/version")) == NULL){
	    clicon_log(LOG_ERR, "grideye_agent: %s: <version> not found in payload",
		       __FUNCTION__);
	    retval = 0; 	    /* sanity check failed, just continue */
	    errpkts++;
	    goto done;
	}
	xb = xml_body(x);
	if (xb==NULL || atoi(xb) != GRIDEYE_AGENT_VERSION){
	    clicon_log(LOG_ERR, "grideye_agent: %s: Sender version %d expected, received %s",
		       __FUNCTION__, GRIDEYE_AGENT_VERSION, xb);
	    retval = 0; 	    /* sanity check failed, just continue */
	    errpkts++;
	    goto done;
	}
	/* Verify name of agent */
	if ((x = xpath_first(xt, "grideye/name")) == NULL){
	    clicon_log(LOG_ERR, "grideye_agent: %s: <name> not found in payload",
		       __FUNCTION__);
	    retval = 0; 	    /* sanity check failed, just continue */
	    errpkts++;
	    goto done;
	}
	xb = xml_body(x);
	if (xb==NULL || strcmp(xb, myname)){
	    clicon_log(LOG_ERR, "grideye_agent: %s: Expected name %s but received %s",
		       __FUNCTION__, myname, xb);
	    retval = 0; 	    /* sanity check failed, just continue */
	    errpkts++;
	    goto done;
	}
	/* Invoke plugins */
	if (xpath_vec(xt, "grideye/plugin", &xvec, &xlen) < 0)
	    goto done;
	/* Loop through plugin calls */
	for (i=0; i<xlen; i++){
	    xp = xvec[i];
	    if ((x = xpath_first(xp, "name")) == NULL){
		clicon_log(LOG_ERR, "grideye_agent: %s: <name> expected in plugin",
			   __FUNCTION__);
		retval = 0; 	    /* sanity check failed, just continue */
		errpkts++;
		goto done;
	    }
	    pstr = xml_body(x);
	    /* Find matching plugin */
	    if ((p = plugin_find(pstr)) == NULL)
		continue; /* silently ignore */
	    if (p->p_disable)
		continue; /* silently ignore */
	    if ((api = p->p_api) == NULL)
		continue; /* silently ignore */
	    /* XXX only single argument */
	    argstr = NULL;
	    if ((x = xpath_first(xp, "param")) != NULL)
		argstr = xml_body(x);

	    if (api->gp_test_fn != NULL){
		clicon_log(LOG_DEBUG, "grideye_agent: %s name:%s(%s)",
			   __FUNCTION__, p->p_name, argstr?argstr:"");

		if (api->gp_magic == (GRIDEYE_PLUGIN_MAGIC & GRIDEYE_PLUGIN_PYTHON)) {
		    if ((str = grideye_call_method(api->gp_name,
						   (char *)api->gp_test_fn,
						   argstr)) == NULL)
			continue;
		    clicon_log(LOG_NOTICE, "Returned %s", str);
		} else {
		    if ((pret = api->gp_test_fn(argstr, &str)) < 0) {
			clicon_log(LOG_NOTICE, "grideye_agent: Plugin: %s failed: %s",
				   p->p_name, str?str:"");
			continue;
		    }
		}

		if (str){
		    if ((api->gp_output_format==NULL && 
			 strcmp(GRIDEYE_PLUGIN_OUTPUT_FORMAT, "json")==0)||
			strcmp(api->gp_output_format, "json")==0){
			cxobj *xt= NULL;
			if (json_parse_str(str, &xt) < 0)
			    goto done;
			xml_rootchild(xt,0,&xt);
			if (xml2json_cbuf(cb, xt, 0) < 0)
			    goto done;
			xml_free(xt);
		    }
		    else if ((api->gp_output_format==NULL && strcmp(GRIDEYE_PLUGIN_OUTPUT_FORMAT, "xml")==0)||
			strcmp(api->gp_output_format, "xml")==0){
			if (xml_parse_string(str, NULL, &xt) < 0)
			    goto done;
			cprintf(cb, "%s", str);
			xml_free(xt);
		    }
		    else{
			clicon_err(OE_PLUGIN, 0, "Inavlid output format %s (%s)", api->gp_output_format, GRIDEYE_PLUGIN_OUTPUT_FORMAT);
			goto done;
		    }
		    free(str);
		    str = NULL;
		}
	    }
	}
    } /* payload */

    clicon_log(LOG_DEBUG, "grideye_agent: %s return:%s", __FUNCTION__, cbuf_get(cb));
    retval = 1; /* OK */
 done:
    if (xvec)
       free(xvec);
    if (xt)
	xml_free(xt);
    if (v)
	free(v);
    if (vi)
	free(vi);
    return retval;
}


static int
echo_application_xml(cxobj         *xt,
		     cbuf          *cb,
		     struct plugin  plugins[])
{
    int                retval = -1;
    uint64_t          *v = NULL;
    int64_t           *vi = NULL;
    int                i;
    struct plugin     *p;
    struct grideye_plugin_api *api;
    char              *argstr;
    char              *pstr;
    int                pret;
    char              *str = NULL;
    cxobj             *x;
    cxobj             *xp;
    cxobj            **xvec = NULL;
    size_t             xlen;

    clicon_log(LOG_DEBUG, "grideye_agent: %s", __FUNCTION__);
    /* Invoke plugins */
    if (xpath_vec(xt, "plugin", &xvec, &xlen) < 0)
	goto done;
    /* Loop through plugin calls */
    for (i=0; i<xlen; i++){
	xp = xvec[i];
	if ((x = xpath_first(xp, "name")) == NULL){
	    clicon_log(LOG_ERR, "grideye_agent: %s: <name> expected in plugin",
		       __FUNCTION__);
	    retval = 0; 	    /* sanity check failed, just continue */
	    errpkts++;
	    goto done;
	}

	pstr = xml_body(x);

	/* Find matching plugin */
	if ((p = plugin_find(pstr)) == NULL)
	    continue; /* silently ignore */
	if (p->p_disable)
	    continue; /* silently ignore */
	if ((api = p->p_api) == NULL)
	    continue; /* silently ignore */

	/* XXX only single argument */
	argstr = NULL;
	if ((x = xpath_first(xp, "param")) != NULL)
	    argstr = xml_body(x);

	if (api->gp_test_fn != NULL) {

	    if (api->gp_magic == (GRIDEYE_PLUGIN_MAGIC & GRIDEYE_PLUGIN_PYTHON)) {
		if ((str = grideye_call_method(api->gp_name,
					       (char *)api->gp_test_fn,
					       argstr)) == NULL)
		    continue;
	    } else {
		if ((pret = api->gp_test_fn(argstr, &str)) < 0) {
		    clicon_log(LOG_NOTICE, "grideye_agent: Plugin: %s failed: %s",
			       p->p_name, str?str:"");
		    continue;
		}
	    }
	    if (str) {
		if (strcmp(api->gp_output_format, "json")==0){
		    cxobj *xt= NULL;
		    if (json_parse_str(str, &xt) < 0)
			goto done;
		    xml_rootchild(xt,0,&xt);
		    if (xml2json_cbuf(cb, xt, 0) < 0)
			goto done;
		    xml_free(xt);
		}
		else
		    cprintf(cb, "%s", str); /* XML */
		free(str);
		str = NULL;
	    }
	}
    }

    clicon_log(LOG_DEBUG, "grideye_agent: %s return:%s", __FUNCTION__, cbuf_get(cb));
    retval = 1; /* OK */
 done:
    if (xvec)
       free(xvec);
    if (v)
	free(v);
    if (vi)
	free(vi);
    return retval;
}

/*! Receive a packet, do stuff, and return it
 *                          no application monitoring
 * @param[in]      eid64str EID64 string, given or random for this agent
 * @param[in]      wi       Wireless interface name, or NULL if no wlan tests
 * @param[in]      name     If set with -n the name
 * @param[oit]     ok       Set to 1 if an OK (eg known sender) pkt arrived
 * xcontrol:  Ctrl hdr has been received and this is the one
 * snd:  0    A data packet has been received from an unregistered sender
 * snd:  1    A data packet has been received from a registered sender
 *     xcontrol  snd
 *       0       0           No ctrl hdr has been received
 *       0       1
 *       1       0           Most recent ctrl hdr
 *       1       1
 *------------------------------
 */
static int
echo_packet(int            s,
	    struct timeval t1, /* when received */
	    char          *buf,
	    int            buflen,
	    char          *eid64str,
	    int            loss,
	    int            reorder,
	    int            duplicate,
	    char          *wi,
	    struct plugin  plugins[],
	    char          *myname,
	    int           *ok
	    )
{
    int                retval = -1;
    struct msghdr      msg;
    struct iovec       iov[1];
    struct cmsghdr    *cmsg;
    struct timeval     t0; /* from sender */
    struct timeval     t2;
    struct timeval     dt;  /* t1-t0 */
    char               cmsgbuf[64];
    struct twoway_hdr  th;
    uint32_t           tag;
    cbuf              *cb = NULL; /* return payload */
    int                fromlen;
    struct sockaddr_in from={0,};
    uint32_t           sseq = 0; // debug only
    uint32_t           rlen = 0;
    uint32_t           slen;
    char              *dpayload = NULL;
    struct sender     *snd = NULL; /* Sender of received data packet */
    int                len;
    cxobj             *xpayload = NULL;
    int                ver;
    enum mtype         mtype;

    //    xr = NULL;
    memset(&msg, 0, sizeof(msg));
    memset(iov, 0, sizeof(iov));
    iov[0].iov_base = buf;
    iov[0].iov_len  = buflen;
    msg.msg_iov     = iov;
    msg.msg_iovlen  = 1;
    fromlen = sizeof(from);
    msg.msg_name = &from;
    msg.msg_namelen = fromlen;
    memset(cmsgbuf, 0, 64);
    cmsg = (struct cmsghdr *)cmsgbuf;
    msg.msg_control = cmsg;
    msg.msg_controllen = 64;

    /* Here is where the message is actually read */
    if ((len = recvmsg(s, &msg, 0x0)) < 0){
	clicon_err(OE_UNIX, errno, "recvmsg");
	goto done;
    }
    clicon_log(LOG_DEBUG, "grideye_agent: %s: recvmsg from: %s:%hu", __FUNCTION__,
	       inet_ntoa(from.sin_addr),
	       ntohs(from.sin_port)
	       );
    if (len == 0){
	clicon_log(LOG_WARNING, "grideye_agent: %s: close socket, len=0", __FUNCTION__);
	goto done;
    }
    if (len < 8){
	clicon_log(LOG_WARNING, "grideye_agent: %s: dropped packet len:%d",
		   __FUNCTION__, len);
	retval = 0; 	    /* sanity check failed, just continue */
	errpkts++;
	goto done;
    }
#if 1
    clicon_log(LOG_DEBUG, "%s: pkt dump: [%02x%02x%02x%02x %02x%02x%02x%02x]",
	       __FUNCTION__,
	       buf[0]&0xff, buf[1]&0xff, buf[2]&0xff, buf[3]&0xff,
	       buf[4]&0xff, buf[5]&0xff, buf[6]&0xff, buf[7]&0xff);
#endif

#ifdef DUMPMSGFILE
    /* This is for record / replay with nc -u */
    {
	static int ii=0;
	char filename[1024];
	FILE *f;
	snprintf(filename, 1024, "%s%d", DUMPMSGFILE, ii++);
	if ((f = fopen(filename, "w")) == NULL){
	    clicon_err(OE_UNIX, errno, "fopen");
	    goto done;
	}
	fwrite(buf, 1, len, f);
	fclose(f);
    }
#endif
    /* Peek straight into message before decoding, see twoway_hdr */
    ver   = buf[0];
    mtype = buf[1];
    tag   = ((int*)buf)[1]; /* Second 32-bit word for twoway. */
    if (ver != PROTO_VERSION){
	clicon_log(LOG_WARNING, "grideye_agent: %s: dropped version:'%d'",
		   __FUNCTION__, ver, ver);
	retval = 0;
	errpkts++;
	goto done;
    }
    if (ntohl(tag) != TWOWAY_TAG){
	clicon_log(LOG_WARNING, "grideye_agent: %s: unexpected tag :0x%x",
		   __FUNCTION__, ntohl(tag));
	retval = 0;
	errpkts++;
	goto done;
    }
    if (mtype != MTYPE_TWOWAY){
	clicon_log(LOG_WARNING, "grideye_agent: %s: Not expected message type :%d",
		   __FUNCTION__, mtype);
	retval = 0; 	    /* sanity check failed, just continue */
	errpkts++;
	goto done;
    }
    switch (mtype){
    case MTYPE_TWOWAY:
	clicon_log(LOG_DEBUG, "grideye_agent: %s: MTYPE_TWOWAY", __FUNCTION__);
	/* Check sender registered in callhome_http*/
	if ((snd = s_find(msg.msg_name, msg.msg_namelen)) == NULL){
	  clicon_log(LOG_DEBUG, "grideye_agent: Unregistered twoway sender %s:%hu",
		     inet_ntoa(from.sin_addr), ntohs(from.sin_port));
	    retval = 0; 	    /* sanity check failed, just continue */
	    errpkts++;
	    goto done;
	}
	if (decode_twoway(buf, len, &th, &dpayload, &rlen) < 0){
	    clicon_log(LOG_DEBUG, "grideye_agent: %s: dropped packet decode_twoway len:%d",
		       __FUNCTION__, len);
	    retval = 0; 	    /* sanity check failed, just continue */
	    errpkts++;
	    goto done;
	}
	if (reorder){
	    if (reorder == th.th_seq0){
		clicon_log(LOG_DEBUG, "grideye_agent: Reorder %d -> %d", th.th_seq0, th.th_seq0+1);
		th.th_seq0 = th.th_seq0+1;
	    }
	    else if (reorder+1 == th.th_seq0){
		clicon_log(LOG_DEBUG, "grideye_agent: Reorder %d -> %d", th.th_seq0, th.th_seq0-1);
		th.th_seq0 = th.th_seq0-1;
	    }
	}
	sseq = th.th_seq0;
	t0 = th.th_t0;
	break;
    default:
	retval = 0;
	errpkts++;
	goto done;
    	break;
    }
    /*
     * A data-packet has been received. This is its state:
     * snd holds it control state if any. If snd=NULL the control packet has
     * not received yet or it is just a non-grideye_sender
     */
    *ok = 1; /* ok pkt */
    for (cmsg=CMSG_FIRSTHDR(&msg); cmsg!=NULL; cmsg=CMSG_NXTHDR(&msg,cmsg)) {
	if (cmsg->cmsg_type==IP_TTL) {
	    if (CMSG_DATA(cmsg) !=  NULL){
//			ttl = *(int*)CMSG_DATA(cmsg);
		break;
	    }
	}
    }
#if 0
    if (SEQ_LEQ(i,last))
	fprintf(stderr, "Duplicated or reordered packet %d\n", i);
    else
	last = i;
#endif
    /*
     * Here starts actual tests. Would like this to be more generic,
     * ie easy to add new tests.
     */
    /* Global packet counter */
    pkts++;
    if (pkts == 1)
	firstpkt = t1;
    lastpkt = t1;
    /* Payload buffer. If no registered sender this is empty */
    if ((cb = cbuf_new()) ==NULL){
	clicon_err(OE_PLUGIN, errno, "cbuf_new");
	goto done;
    }

    /* Here starts 'Application monitoring' ie 'programable behaviour'
     * Only do this if sender is known and if we have received grideye
     * control packets
     */
    if (snd != NULL){
	/* Problem: three-value return
	 * Fatal error: -1 and quit
	 * Drop: 0: return 0, break
	 * OK: 1 continue
	 */
	if ((retval = echo_application(snd, myname, dpayload, cb, plugins)) < 0)
	    goto done;
	if (retval == 0)
	    goto done;
	retval = -1;
    }
    slen = sizeof(th)+cbuf_len(cb)+1;
    t2 = gettimestamp();

    if (snd)
	th.th_seq1 = snd->s_seq++;
    th.th_t1 = t1;
    th.th_t2 = t2;
    if (encode_twoway(buf, slen, &th, cbuf_get(cb)) < 0)
	goto done;
    /* Simulated loss and duplicate for debugging */
    if (loss && loss == sseq)
	clicon_log(LOG_DEBUG, "grideye_agent: Loss %d", sseq);
    else{
	if (send_one_agent(s, msg.msg_name, msg.msg_namelen, buf, slen) < 0)
	    goto done;
    }
    if (duplicate && duplicate==sseq){
	clicon_log(LOG_DEBUG, "grideye_agent: Duplicate %d", sseq);
	if (send_one_agent(s, msg.msg_name, msg.msg_namelen, buf, slen) < 0)
	    goto done;
    }

    if (debug){
	timersub(&t1, &t0, &dt);
	clicon_log(LOG_DEBUG, "grideye_agent: %s seq: %u %lu.%06lu",
		   __FUNCTION__, sseq, dt.tv_sec, dt.tv_usec);
    }
    retval = 0;
  done:
    clicon_debug(1, "%s retval: %d", __FUNCTION__, retval);
    if (xpayload)
	xml_free(xpayload);
    if (cb)
	cbuf_free(cb);
    return retval;
}

/*! This is signaling: create agent to send to this agent 
 * Send a CURL POST to controller and register (or change) existing agent.
 * @param[in]  url
 * @param[in]  name
 * @param[in]  id
 * @param[in]  proto
 * @param[in]  myaddr        Address, port of locally bound socket
 * @param[in]  info          Info about this node/agent
 * @param[in]  curl_timeout  Curl post request timeout in seconds
 * @param[in]  xym           yang metrics required for this agent
 * @param[in,out] natstate   0:none 1:enabled 2:addr&port defined 3: connected
 * @see nattraversal_udp
 * XXX: problem with using curl primary_ip in registering server. Eg curl localhost can resolve to
 *      ::1 , 127.0.1.1 or 127.0.0.1 but the server sender can use typically 127.0.0.1
 */
static int
callhome_http(char               *url,
	      char               *name,
	      char               *id,
	      enum grideye_proto  proto,
	      struct sockaddr_in *myaddr,
	      char               *info,
	      int                 curl_timeout,
	      cxobj              *xym,
	      int                *natstate)
{
    int    retval = -1;
    cbuf  *ub = NULL;
    cbuf  *cb = NULL;
    char  *getdata = NULL;
    cxobj *xreply = NULL;
    cxobj *x;
    int    udp_sport;
    char  *remoteip = NULL;
    int    haddr; /* nat addr */
    struct sender *snd = NULL;
    struct sockaddr_in sndaddr = {0,};
    struct plugin *p;
    int    i;
    int    ret;
    char  *err = NULL;

    clicon_debug(1, "%s", __FUNCTION__);
    if ((ub = cbuf_new()) == NULL){ /* URL */
      clicon_err(OE_UNIX, errno, "cbuf_new");
      goto done;
    }
    if ((cb = cbuf_new()) == NULL){ /* data */
      clicon_err(OE_UNIX, errno, "cbuf_new");
      goto done;
    }
    cprintf(cb, "{\"input\":{");
    cprintf(cb, "\"name\":\"%s\",", name);
    cprintf(cb, "\"id\":\"%s\",", id);
    if (myaddr && myaddr->sin_port) /* tcp may have port 0 since agent will connect later */
	cprintf(cb, "\"port\":%hu,", ntohs(myaddr->sin_port));
    cprintf(cb, "\"version\":%u,", GRIDEYE_AGENT_VERSION);
#if 1
    if (xym){
	cbuf *cbtmp;
	char *str;
	if ((cbtmp=cbuf_new()) == NULL)
	    goto done;
	if (xml2json_cbuf_vec(cbtmp, xml_childvec_get(xym),xml_child_nr(xym), 0) < 0)
	    goto done;
	str = cbuf_get(cbtmp);
	str++;
	str[strlen(str)-1] = '\0';
	cprintf(cb, "%s,", str);
	cbuf_free(cbtmp);
    }
#endif
    if (info)
	cprintf(cb, "\"info\":\"%s\",", info);
    cprintf(cb, "\"plugins\":[");
    i = 0;
    for (p = plugins; (p->p_api!=NULL); p++){
	if (p->p_disable)
	    continue;
	if (i++)
	    cprintf(cb, ",");
	cprintf(cb, "\"%s\"", p->p_name);
    }
    cprintf(cb, "],");
    cprintf(cb, "\"proto\":\"%s\"", grideye_proto2str(proto));
    cprintf(cb, "}}");
    cprintf(ub, "%s/restconf/operations/grideye:callhome", url);
    ret = url_post(cbuf_get(ub), cbuf_get(cb), "Content-Type: application/yang-data+json", NULL, curl_timeout,
		   &getdata, &remoteip);
    switch (ret){
    case -2: /* fatal */
	goto done;
    case -1: /* non-fatal */
	*natstate = 0;
	goto ok;
    default:
	break;
    }
    if (getdata == NULL)
	goto done;

    /* xml parse reply: here is where we get the port */
    switch (proto){
    case GRIDEYE_PROTO_TCP:
    case GRIDEYE_PROTO_UDP:
	if (getdata==NULL)
	    break;
	clicon_debug(1, "grideye_agent: %s remoteip:%s getdata:%s", __FUNCTION__,
		   remoteip, getdata);
	if (json_parse_str(getdata, &xreply) < 0){
	    clicon_log(LOG_WARNING,  "grideye_agent: %s: json parse error: %s", __FUNCTION__, getdata);
	    /* Note this could actually be html, eg broken xml */
	    retval = 0;
	    goto done;
	}
	clicon_log(LOG_DEBUG,  "grideye_agent: %s: xml OK", __FUNCTION__);
	if (*natstate > 0 && remoteip && xreply){
	    *natstate = 1;/* if changed sender, natstate may be 2 */
	clicon_log(LOG_DEBUG,  "grideye_agent: %s: natstate to 1", __FUNCTION__);
	    sndaddr.sin_family = AF_INET;
#ifdef HAVE_SIN_LEN
	    sndaddr.sin_len = sizeof(sndaddr);
#endif
	    if ((haddr = inet_addr(remoteip)) != -1)
		sndaddr.sin_addr.s_addr = haddr;
	    if ((x = xpath_first(xreply, "//udp_sport")) != NULL){
		if ((udp_sport = atoi(xml_body(x))) != 0){
		    sndaddr.sin_port = htons(udp_sport);
		    *natstate = 2;
		}
	    }
	    else
		clicon_log(LOG_DEBUG, "grideye_agent: %s: no udp sport", __FUNCTION__);
	    if (*natstate > 1){
		/* register sender */
		if ((snd = s_find(&sndaddr, sizeof(sndaddr))) == NULL){
		    if ((snd = s_add(&sndaddr, sizeof(sndaddr))) == NULL)
			goto done;
		    /* XXX for TCP do connect */
		    clicon_log(LOG_DEBUG, "grideye_agent: Registered new sender %s:%hu",
			       inet_ntoa(sndaddr.sin_addr),
			       ntohs(sndaddr.sin_port));
		    if ((snd->s_name = strdup(name)) == NULL){
			clicon_err(OE_UNIX, errno, "strdup");
			goto done;
		    }
		}
		if (snd->s_xml != NULL)
		    xml_free(snd->s_xml); /* delete old tree */
		snd->s_xml = xreply;
		xreply = NULL;
	    }
	}
	break;
    case GRIDEYE_PROTO_HTTP:
	/* XXX KLUDGE TO SEE IF IT IS XML. ERROR COMES AS HTML 
	 * In all cases, go back to callhome mode.
	 * If HTML, then we cant use XML parser, since it is not properly formed.
	 */
	if (getdata[0] == '<'){
	    if (strncmp(getdata,"<html", strlen("<html")) == 0){
		clicon_log(LOG_WARNING,  "%s: Unexpected controller reply: %s", __FUNCTION__, getdata);
	    }
	    else if (xml_parse_string(getdata, NULL, &xreply) < 0)
		clicon_log(LOG_WARNING,  "%s: xml parse error: %s", __FUNCTION__, getdata);
	    else
		clicon_log(LOG_WARNING,  "%s: Unexpected controller reply: %s", __FUNCTION__, getdata);
	    *natstate = 0;
	    goto ok;
	}
	if (json_parse_str(getdata, &xreply) < 0){
	    clicon_log(LOG_WARNING,  "%s: json parse error: %s", __FUNCTION__, getdata);
	    *natstate = 0;
	    goto ok;
	}
	/* If not regular output, it is an error*/
	if (xpath_first(xreply, "output") == NULL){
	    if ((x = xpath_first(xreply, "//error-message")) != NULL)
		err = xml_body(x);
	    if ((x = xpath_first(xreply, "//error-tag")) != NULL)
		clicon_log(LOG_WARNING,  "%s: error: %s: %s", __FUNCTION__, xml_body(x), err?err:"");
	    *natstate = 0;
	    goto ok;
	}
	*natstate = 2;
	break;
    default:
      break;
    }
 ok:
    retval = 0;
 done:
    if (remoteip)
	free(remoteip);
    if (xreply)
	xml_free(xreply);
    if (getdata)
	free(getdata);
    if (ub)
	cbuf_free(ub);
    if (cb)
	cbuf_free(cb);
    return retval;
}

/*!
 * @param[in]     url       URL - where to send http data to
 * @param[in]     name
 * @param[in]     timeout   Curl post request timeout in seconds
 * @param[in,out] natstate  0:none 1:enabled 2:addr&port defined 3: connected
 * @param[out]    interval  
 * @param[out]    xplugin   This is test initiator received from the controller
 */
static int
http_data(char               *url,
	  char               *name,
	  char               *id,
	  cbuf               *cbmetr,
	  uint64_t           *sseq,
	  int                *tvalid,
	  struct timeval     *t0,
	  struct timeval     *t1,
	  int                 curl_timeout,
	  int                *natstate,
	  int                *interval,
	  cxobj             **xplugin)
{
    int     retval = -1;
    cbuf   *ub = NULL;
    cbuf   *cb = NULL;
    char   *getdata = NULL;
    cxobj  *xreply = NULL;
    cxobj  *x;
    char   *remoteip = NULL;
    struct timeval t2;
    int64_t i64;
    static uint64_t aseq=0;
    int     ret;
    char   *xbody;
    char   *reason = NULL;
    char   *err = NULL;

    clicon_debug(1, "%s", __FUNCTION__);
    *interval = 10000; /* 10s default, on error can be 0 */
#ifdef FUZZ
    if (fuzz)
	*interval = 1;
#endif
    if ((ub = cbuf_new()) == NULL){ /* URL */
      clicon_err(OE_UNIX, errno, "cbuf_new");
      goto done;
    }
    if ((cb = cbuf_new()) == NULL){ /* data */
      clicon_err(OE_UNIX, errno, "cbuf_new");
      goto done;
    }
    cprintf(cb, "<input>");
    cprintf(cb, "<name>%s</name>", name);
    cprintf(cb, "<userid>%s</userid>", id);
    cprintf(cb, "<sseqn>%" PRIu64 "</sseqn>", *sseq);
    if (cbmetr){
	cprintf(cb, "<aseqn>%" PRIu64 "</aseqn>", aseq++);
	if (*tvalid){
	    cprintf(cb, "<t0>%ld.%06ld</t0>", t0->tv_sec, t0->tv_usec);
	    cprintf(cb, "<t1>%ld.%06ld</t1>", t1->tv_sec, t1->tv_usec);
	}
	gettimeofday(&t2, NULL);
	cprintf(cb, "<t2>%ld.%06ld</t2>", t2.tv_sec, t2.tv_usec);
	cprintf(cb, "%s", cbuf_get(cbmetr));
    }
    cprintf(cb, "</input>");
    cprintf(ub, "%s/restconf/operations/grideye:agent-data", url);
    /* XXX return is JSON */
    ret = url_post(cbuf_get(ub), cbuf_get(cb), "Content-Type: application/yang-data+xml",
		   NULL, curl_timeout, &getdata, &remoteip);
    switch (ret){
    case -2: /* fatal */
	goto done;
	break;
    case -1: /* non-fatal */
	*natstate = 0;
	goto ok;
    default:
	break;
    }
    *tvalid = 0;
    gettimeofday(t1, NULL);
    /* XXX KLUDGE TO SEE IF IT IS XML. ERROR COMES AS HTML 
     * In all cases, go back to callhome mode.
     * If HTML, then we cant use XML parser, since it is not properly formed.
     */
    if (getdata[0] == '<'){
	if (strncmp(getdata,"<html", strlen("<html")) == 0){
	    clicon_log(LOG_WARNING,  "%s: Unexpected controller reply: %s", __FUNCTION__, getdata);
	}
	else if (xml_parse_string(getdata, NULL, &xreply) < 0)
	    clicon_log(LOG_WARNING,  "%s: xml parse error: %s", __FUNCTION__, getdata);
	else
	    clicon_log(LOG_WARNING,  "%s: Unexpected controller reply: %s", __FUNCTION__, getdata);
	*natstate = 0;
	goto ok;
    }
    if (json_parse_str(getdata, &xreply) < 0){
	clicon_log(LOG_WARNING,  "%s: json parse error: %s", __FUNCTION__, getdata);
	goto ok;
    }
    /* If not regular output, it is an error*/
    if (xpath_first(xreply, "output") == NULL){
	if ((x = xpath_first(xreply, "//error-message")) != NULL)
	    err = xml_body(x);
	if ((x = xpath_first(xreply, "//error-tag")) != NULL)
	    clicon_log(LOG_WARNING,  "%s: error: %s: %s", __FUNCTION__, xml_body(x), err?err:"");
	*natstate = 0;
	goto ok;
    }
    if ((x = xpath_first(xreply, "//interval")) != NULL){
	xbody = xml_body(x);
	*interval = atoi(xbody);
    }
    if ((x = xpath_first(xreply, "//sseqn")) != NULL){
	xbody = xml_body(x);
	*sseq = atoi(xbody);
    }
    if ((x = xpath_first(xreply, "//t0")) != NULL){
	if ((xbody = xml_body(x)) == NULL){
	    clicon_log(LOG_WARNING,  "%s: No t0 timestamp", __FUNCTION__);
	    *natstate = 0;
	    goto ok;
	}
	if (parse_dec64(xbody, 6, &i64, &reason) < 0){
	    clicon_err(OE_XML, errno, "parse_dec64: %s", xbody);
	    goto done;
	}
	if (reason){
	    clicon_log(LOG_WARNING,  "%s: Invalid timestamp %s: %s", __FUNCTION__, xbody, reason);
	    *natstate = 0;
	    goto ok;
	}
	t0->tv_sec = i64/1000000;;
	t0->tv_usec = i64%1000000;
	*tvalid = 1;
    }
    if ((x = xpath_first(xreply, "output")) != NULL)
	if (xml_copy(x, *xplugin) < 0)
	    goto done;
 ok:
    retval = 0;
 done:
    clicon_debug(1, "%s retval:%d", __FUNCTION__, retval);
    if (reason)
	free(reason);
    if (remoteip)
	free(remoteip);
    if (xreply)
	xml_free(xreply);
    if (getdata)
	free(getdata);
    if (ub)
	cbuf_free(ub);
    if (cb)
	cbuf_free(cb);
    return retval;
}

/*! This is for NAT traversal: send udp towards server just to open existing stream 
 * Timeout only when there havent been any packets for some time.
 * @param[in]  s         Socket to send on
 * @param[in]  myaddr    Address, port of locally bound socket
 * @param[in]  sndaddr   Address to send a nat traversal probe packet to.
 * @param[in]  buf       Raw message buffer to re-use
 * @param[in]  len       Length of message buffer buf
 * @param[in]  name      Name of sender/agent
 * @param[in]  eid64str  EID64 string, given or random for this agent
 * @see callhome_http
 */
static int
nattraversal_udp(int                 s,
		 struct sockaddr_in *myaddr,
		 char               *name,
		 char               *eid64str)
{
    int                retval = -1;
    struct control_hdr ch0;
    int                clen;
    cbuf              *xmlbuf = NULL;
    char               buf[BUFSIZE];
    int                len = BUFSIZE;
    struct sockaddr_in *sndaddr;
    struct sender      *snd;

    if ((snd = s_list) == NULL)
	return 0;
    sndaddr = (struct sockaddr_in *)(snd->s_sname);
    clicon_log(LOG_DEBUG, "grideye_agent: %s nat probe address : %s:%u",
		 __FUNCTION__,
		 inet_ntoa(sndaddr->sin_addr),
		 ntohs(sndaddr->sin_port));
    assert(sndaddr->sin_port);
    memset(&ch0, 0, sizeof(ch0));
    ch0.ch_ver   = PROTO_VERSION;
    ch0.ch_mtype = MTYPE_CONTROL;
    ch0.ch_tag2  = TWOWAY_TAG;
    if ((xmlbuf = cbuf_new()) == NULL)
	goto done;
    cprintf(xmlbuf, "<grideye><version>%d</version><name>%s</name><E64>%s</E64>", 
	    GRIDEYE_AGENT_VERSION,
	    name,
	    eid64str);
    cprintf(xmlbuf, "</grideye>");
    if ((clen = encode_control(buf, len, &ch0, cbuf_get(xmlbuf))) < 0)
	goto done;
    if (send_one_agent(s,
		       (struct sockaddr*)sndaddr,
		       sizeof(*sndaddr),
		       buf, clen) < 0){
	goto done;
    }
    retval = 0;
 done:
    if (xmlbuf)
	cbuf_free(xmlbuf);
    return retval;
}


/* For linux /proc */
#define PROC_CPUINFO "/proc/cpuinfo"
static int
get_system_info(char **info)
{
    int   retval = -1;
    FILE *f = NULL;
    char  buf[1024];
#ifdef __APPLE__
    struct utsname name;
    if (uname(&name) < 0){
      clicon_err(OE_UNIX, errno, "uname");
      goto done;
    }
    snprintf(buf, 1024, "%s %s", name.sysname, name.release);
    if ((*info = strdup(buf))==NULL){
      clicon_err(OE_UNIX, errno, "strdup");
      goto done;
    }
#else

    char *line;
    char *s;

    if ((f = fopen(PROC_CPUINFO, "r")) == NULL)
	goto done;
    while ((line = fgets(buf, sizeof(buf), f)) != NULL){
	if ((s = strstr(line, "model name")) == NULL)
	    continue;
	s+=strlen("model name")+3;
	if (s[strlen(s)-1] == '\n')
	    s[strlen(s)-1] = '\0';
	if ((*info = strdup(s))==NULL){
	    clicon_err(OE_UNIX, errno, "strdup");
	    goto done;
	}
	break;
    }
#endif
    retval = 0;
 done:
    if (f != NULL)
	fclose(f);
    return retval;
}

/*! This is for NAT traversal: connect via tcp to grideye_sender
 * Timeout only when there havent been any packets for some time.
 * @param[in]  s         Socket to send on
 * @param[in]  myaddr    Address, port of locally bound socket
 * @param[in]  sndaddr  Address to send a nat traversal probe packet to.
 * @param[in]  buf       Raw message buffer to re-use
 * @param[in]  len       Length of message buffer buf
 * @param[in]  name      Name of sender/agent
 * @param[in]  eid64str  EID64 string, given or random for this agent
 * @see callhome_http
 */
static int
nattraversal_tcp(int                 s,
		 struct sockaddr_in *myaddr,
		 char               *name,
		 char               *eid64str,
		 int                *natstate)
{
    int                retval = -1;
    struct control_hdr ch0;
    int                clen;
    cbuf              *xmlbuf = NULL;
    char               buf[BUFSIZE];
    int                len = BUFSIZE;
    struct sockaddr_in *sndaddr;
    struct sender      *snd;

    clicon_log(LOG_DEBUG, "grideye_agent: %s", __FUNCTION__);
    if ((snd = s_list) == NULL)
	return 0;
    sndaddr = (struct sockaddr_in *)(snd->s_sname);

    clicon_log(LOG_DEBUG, "grideye_agent: %s Trying to connect to : %s:%u",
		 __FUNCTION__,
		 inet_ntoa(sndaddr->sin_addr),
		 ntohs(sndaddr->sin_port));
    if (connect(s, (struct sockaddr *)sndaddr, sizeof(*sndaddr)) < 0){
	clicon_err(OE_UNIX, errno, "connect");
	goto done;
    }
    clicon_log(LOG_DEBUG, "grideye_agent: %s connectected to : %s:%u",
		 __FUNCTION__,
		 inet_ntoa(sndaddr->sin_addr),
		 ntohs(sndaddr->sin_port));
    memset(&ch0, 0, sizeof(ch0));
    ch0.ch_ver   = PROTO_VERSION;
    ch0.ch_mtype = MTYPE_CONTROL;
    ch0.ch_tag2  = TWOWAY_TAG;
    if ((xmlbuf = cbuf_new()) == NULL)
	goto done;
    cprintf(xmlbuf, "<grideye><version>%d</version><name>%s</name><E64>%s</E64>", 
	    GRIDEYE_AGENT_VERSION,
	    name,
	    eid64str);
    cprintf(xmlbuf, "</grideye>");
    if ((clen = encode_control(buf, len, &ch0, cbuf_get(xmlbuf))) < 0)
	goto done;
    if (send_one_agent(s, NULL, 0, buf, clen) < 0)
	goto done;
    *natstate = 3;
    retval = 0;
 done:
    clicon_log(LOG_DEBUG, "grideye_agent: %s retval:%d",
	       __FUNCTION__, retval);

    if (xmlbuf)
	cbuf_free(xmlbuf);
    return retval;
}

static void
grideye_sig(int arg)
{
    clicon_log(LOG_NOTICE, "grideye_agent: %s: %d", __FUNCTION__, arg);
}

/*! Exit functions either called on sigterm or end of main */
static void
doexit(int arg)
{
    struct timeval dur;
    void          *handle = NULL;
    struct plugin *p;

    clicon_log(LOG_NOTICE, "grideye_agent: %s: %d", __FUNCTION__, arg);
    timersub(&lastpkt, &firstpkt, &dur);

    if (pidfile)
	unlink(pidfile);
    clicon_log(LOG_NOTICE, "grideye_agent: %s: Terminated: Received %d packets (term) during %ld.%03ld secs",
	    hostname, pkts, dur.tv_sec, dur.tv_usec/1000);
    if (plugins){
	handle = plugins->p_handle;
/* Cant run exit functions here because we may run in interrupt stack */
	for (p = plugins; (p->p_api!=NULL); p++){
	    if (p->p_filename)
		free(p->p_filename);
	    if (p->p_name)
		free(p->p_name);
	}
	free(plugins);
	plugins = NULL;
	if (handle)
	    dlclose(handle);
    }
    while (s_list != NULL)
	s_rm(s_list);
    exit(0);
}

/*!
 * @param[in]  xym           yang metrics required for this agent
 */
static int
callhome(int                 s,
	 char               *callhome_url,
	 char               *hostname,
	 char               *userid,
	 enum grideye_proto  proto,
	 int                *natstate,
	 struct sockaddr_in *myaddr,
	 char               *eid64str,
	 char               *info,
	 int                 curl_timeout,
	 cxobj              *xym
	 )
{
    int            retval = -1;

    clicon_log(LOG_DEBUG, "grideye_agent: %s", __FUNCTION__);
    if (callhome_url && userid){     /* Timeout Send a (call)home message */
	if (callhome_http(callhome_url,
			  hostname,
			  userid,
			  proto,
			  myaddr,
			  info,
			  curl_timeout,
			  xym,
			  natstate) < 0)
	    goto done;
    }
    clicon_log(LOG_DEBUG, "grideye_agent: %s natstate:%d", __FUNCTION__, *natstate);
    if ((*natstate) > 1){     /* Timeout Send a (call)home message */
	switch(proto){
	case GRIDEYE_PROTO_TCP:
	    if (nattraversal_tcp(s,
				 myaddr,
				 hostname,
				 eid64str,
				 natstate) < 0)
		goto done;
	    break;
	case GRIDEYE_PROTO_UDP:
	    if (nattraversal_udp(s,
				 myaddr,
				 hostname,
				 eid64str) < 0)
		goto done;
	    break;
	default:
	    break;
	}
    }
    retval = 0;
 done:
    return retval;
}

static void
usage(char *argv0)
{
    fprintf(stderr, "usage:\t%s [options]*    Receive UDP packets on socket\n"
	    "where options are:\n"
	    "\t-h \t\tHelp text\n"
	    "\t-D \t\tDebug\n"
	    "\t-F \t\tRun in foreground and log to stderr\n"
	    "\t-v \t\tPrint version\n"
	    "\t-q \t\tQuiet\n"
	    "\t-e <eid64> \tDevice identifier (random if not given)\n"
	    "\t-t <s> \t\tCallhome timeout in seconds (if idle) (default:%d)\n"
	    "\t-t <s> \t\tCURL timeout in seconds (if idle) (default:%d)\n"
	    "\t-f <filename>\tLog to file\n"
	    "\t-i <ifname>\t(Local) receiving interface name (see -a)\n"
	    "\t-a <host>\t(Local) hostname or IPv4 address to listen to (see -i) \n"
	    "\t-l <port> Local port\n"
	    "\t-W <dir> \tWorking directory for disk i/o (default: %s). Two\n"
	    "\t\t\tfiles will be created, %s and %s\n"
	    "\t-u <url>\tCall home URL. Send if no rx traffic in -t s\n"
	    "\t-I <id>\t\tId to use with -u\n"
	    "\t-N <name>\tName to use in logs and callhome. default is hostname\n"
	    "\t-p udp|tcp|http\tData protocol to use with -u. Default http\n"
	    "\t-r \t\tSynthetic reorder of pkt 30\n"
	    "\t-L \t\tSynthetic loss of pkt 20\n"
	    "\t-d \t\tSynthetic duplicate of pkt 40\n"
#ifdef FUZZ
	    "\t-Z \t\tFuzz (afl) simulation\n"
#endif
	    "\t-w [ifname]\tWireless interface\n"
	    "\t-P <dir>\tPlugin directory(default: %s)\n"
	    "\t-z \t\tKill other config daemon and exit\n"
	    "\t-k <pidfile> \tPidfile, default: %s\n"
	    "\t-s \t\tDon't verify the servers SSL certificate, MUCH less secure.\n"
	    "\t-s -s \tConnection succeeds regardless of the names in the certificate.\n",
	    argv0,
	    CALLHOME_DEFAULT,
	    CURL_TIMEOUT_DEFAULT,
	    DISKIO_DIR,
	    DISKIO_LARGEFILE,
	    DISKIO_WRITEFILE,
	    PLUGINDIR,
	    GRIDEYE_AGENT_PIDFILE
	    );
    exit(0);
}

int
main(int   argc,
     char *argv[])
{
    char               *argv0;
    int                 retval = -1;
    int                 s = -1;
    int                 c;
    struct in_addr      inaddr = {0, };
    unsigned short      localport; /* local port */
    struct sockaddr_in  myaddr = {0, };
    fd_set              fdset;
    int                 callhome_timeout;
    char               *filename;
    FILE               *f;
    uint64_t            eid64;
    char                eid64str[24];
    int                 yes;
    int                 n;
    char               *diskio_dir;
    char               *diskio_largefile = NULL;
    char               *diskio_writefile = NULL;
    char               buf[BUFSIZE];
    int                len = BUFSIZE;
    struct timeval     t1; /* when received */
    int                natstate; /* state: 0:none 1:enabled 2:addr&port defined */
    char               *callhome_url;
    struct timeval     tv;
    struct timeval     trnd;
    int                loss;
    int                reorder;
    int                duplicate;
    char               *userid = NULL;
    enum grideye_proto proto;
    char               *wi = NULL; /* Wireless interface */
    //char               *plugin_dir = NULL;
    struct plugin      *p;
    struct grideye_plugin_api *api;
    int                foreground;
    int                slen;
    int                zap;
    pid_t              pid;
    struct stat        st;
    char               *info = NULL;
    int                errno0;
    int                ok;
    char               pidfile[MAXPATHLEN];
    cxobj             *xtest = NULL;
    int                interval = 10000;
    int                ctvalid = 0; /* If ct0 and ct1 are valid */
    struct timeval     ct0;
    struct timeval     ct1;
    uint64_t           sseq = 0;
    int                curl_timeout = CURL_TIMEOUT_DEFAULT;
    cxobj             *xym=NULL; /* XML yang metric tree */
    char              *yangmetric;

    /* Initialization */
    argv0 = argv[0];
    localport = 0;
    natstate = 1;
    callhome_url = NULL;
    callhome_timeout = CALLHOME_DEFAULT; /* timeout for call home */
    filename = NULL;
    f = NULL;
    gettimeofday(&trnd, NULL);
    srandom(trnd.tv_usec); /* init random */
    eid64 = random();
    eid64 = eid64<<32;
    eid64 |= random();
    yes = 1;
    zap = 0;
    diskio_dir  = DISKIO_DIR;
    loss = 0;
    reorder = 0;
    duplicate = 0;
    plugin_dir = PLUGINDIR;
    plugins = NULL;
    foreground = 0;
    proto = GRIDEYE_PROTO_HTTP;
    strncpy(pidfile, GRIDEYE_AGENT_PIDFILE, sizeof(pidfile)-1);
    ssl_verifypeer = 0;
#ifdef FUZZ
    fuzz = 0;
#endif

    /* Hostname for logs and callbacks, overwritten by -N */
    if (gethostname(hostname, sizeof(hostname)) < 0) {
	clicon_err(OE_UNIX, errno, "gethostname");
	exit(0);
    }

    clicon_log_init("grideye_agent", LOG_INFO, CLICON_LOG_STDERR);
    while ((c = getopt(argc, argv, GRIDEYE_AGENT_OPTS)) != -1){
	switch (c) {
	case 'h' : /* help */
	    usage(argv0);
	    break;
	case 'D' : /* debug */
	    debug++;
	    break;
	case 'F' : /* foreground */
	    foreground = 1;
	    break;
	case 'v' : /* version */
	    fprintf(stderr, "Grideye v%s prototype\n", GRIDEYE_VERSION);
	    fprintf(stderr, "%s\n", GRIDEYE_BUILDSTR);
	    exit(0);
	    break;
	case 't' : /* callhome timeout */
	    callhome_timeout = atoi(optarg);
	    break;
	case 'q' : /* be (more) quiet */
	    quiet++;
	    break;
	case 'e' : /* eid */
	    eid64 = atoll(optarg);
	    break;
	case 'f' : /* filename */
	    filename = optarg;
	    break;
	case 'i' : /* interface  (overridden by -a) */
	    if (ifname2addr(optarg, &inaddr) < 0)
		goto done;
	    break;
	case 'a': /* Local address or hostname (overrides -i) */
	    if (host2addr(optarg, &inaddr) < 0) {
		fprintf(stderr, "Invalid address: %s\n", optarg);
		usage(argv0);
	    }
	    break;
	case 'l' : /* local port */
	    localport = atoi(optarg);
	    if (localport <= 0){
		fprintf(stderr, "Invalid local port: %s\n", optarg);
		usage(argv0);
	    }
	    break;
	case 'W':    /* Disk I/O directory */
	    diskio_dir = optarg;
	    break;
	case 'u':    /* URL used with callback */
	    callhome_url = optarg;
	    break;
	case 'I':    /* user id used with callback url */
	    userid = optarg;
	    break;
	case 'N':    /* Name to use with -u and in logs */
	    strncpy(hostname, optarg, sizeof(hostname));
	    hostname[sizeof(hostname) - 1]= '\0';
	    break;
	case 'p':    /* protocol (tcp, udp or http) */
	    if ((proto = grideye_str2proto(optarg)) < 0){
		fprintf(stderr, "Invalid proto: %s\n", optarg);
		usage(argv0);
	    }
	    break;
	case 'r':    /* Synthetic reorder */
	    reorder = 30;
	    break;
	case 'L':    /* Synthetic loss */
	    loss = 20;
	    break;
	case 'd':    /* Synthetic duplicate */
	    duplicate = 40;
	    break;
	case 'w':    /* Wireless interface */
	    wi = optarg;
	    break;
	case 'P':    /* Grideye_agent plugin dir*/
	    plugin_dir = optarg;
	    break;
	case 'z': /* Zap other process */
	    zap++;
	    break;
	case 'k':    /* PID file*/
	    strncpy(pidfile, optarg, sizeof(pidfile)-1);
	    break;
#ifdef FUZZ
	case 'Z':    /* Fuzzing simulation */
	    fuzz++;
	    interval = 1;
	    break;
#endif
	case 's':    /* SSL verify peer */
	    ssl_verifypeer++;
	    break;
	} /* switch */
    } /* while */
    clicon_log(LOG_DEBUG, "grideye_agent: wi:%s", wi);
    /* sensd does not want an 0x%lx but parse_uint64 does */
    snprintf(eid64str, sizeof(eid64str), "0x%" PRIu64, eid64);
    /* Get some system info */
    if (get_system_info(&info) < 0)
	goto done;
    if (pidfile_get(pidfile, &pid) < 0)
	goto done;
    if (zap){
	if (pid && pidfile_zapold(pid) < 0)
	    return -1;
	if (lstat(pidfile, &st) == 0)
	    unlink(pidfile);
	exit(0); /* OK */
    }
    else{
	if (pid){
	    clicon_err(OE_DEMON, 0, "Daemon already running with pid %d\n(Try killing it with %s -z)", 
		       pid, argv0);
	    return -1; /* goto done deletes pidfile */
	}
    }
    /* After this point we can goto done on error
     * Here there is either no old process or we have killed it,..
     */
    if (lstat(pidfile, &st) == 0)
	unlink(pidfile);
    /* Daemonize and initiate logging. Note error is initiated here to make
       demonized errors OK. Before this stage, errors are logged on stderr
       also */
    if (foreground==0){
	clicon_log_init("grideye_agent", debug?LOG_DEBUG:LOG_INFO, CLICON_LOG_SYSLOG);
	if (daemon(0, 0) < 0){
	    fprintf(stderr, "config: daemon");
	    exit(-1);
	}
    }
    /* Write pid-file */
    if ((pid = pidfile_write(pidfile)) <  0)
	goto done;
    if ((plugins = calloc(1, sizeof(struct plugin))) == NULL){
	clicon_err(OE_UNIX, errno, "calloc");
	goto done;
    }
    /* Load test plugins, and call their init functions */
    clicon_log(LOG_NOTICE, "grideye_agent: Plugin: Loading plugins from %s", plugin_dir);

    if (plugin_load_dir(plugin_dir, &plugins) < 0)
	goto done;
    /*
     * Iterate through plugins and call getopt/setopt functions
     * See options definitions in plugin/grideye_plugin.h
     */
    for (p = plugins; (api=p->p_api)!=NULL; p++){
	if (api->gp_getopt_fn) {
	    yangmetric = NULL;

	    if (api->gp_magic == (GRIDEYE_PLUGIN_MAGIC & GRIDEYE_PLUGIN_PYTHON)) {
		if ((yangmetric = grideye_call_method(api->gp_name,
						      (char *)api->gp_getopt_fn,
						      "yangmetric")) == NULL) {
		    clicon_log(LOG_DEBUG, "grideye_agent: Plugin: getopt(yangmetric)");
		    clicon_log(LOG_NOTICE, "grideye_agent: Plugin: Disabling %s (no writefile)",
			       p->p_name, strerror(errno));
		}
	    } else {
		if (api->gp_getopt_fn("yangmetric", &yangmetric) < 0){
		    clicon_log(LOG_DEBUG, "grideye_agent: Plugin: getopt(yangmetric)");
		    clicon_log(LOG_NOTICE, "grideye_agent: Plugin: Disabling %s (no writefile)",
			       p->p_name, strerror(errno));
		}
	    }

	    if (yangmetric) {
		if ((api->gp_input_format==NULL &&
		     strcmp(GRIDEYE_PLUGIN_INPUT_FORMAT, "json")==0)||
		    strcmp(api->gp_input_format, "json")==0){
			if (json_parse_str(yangmetric, &xym) < 0) {
				clicon_log(LOG_NOTICE, "grideye_agent: Could not parse JSON");
				goto done;
			}
		} else if ((api->gp_input_format==NULL &&
			    strcmp(GRIDEYE_PLUGIN_INPUT_FORMAT, "xml")==0)||
			   strcmp(api->gp_input_format, "xml")==0){
			if (xml_parse_string(yangmetric, NULL, &xym) < 0) {
				clicon_log(LOG_NOTICE, "grideye_agent: Could not parse XML");
				goto done;
			}
		}

		free(yangmetric);
		yangmetric = NULL;
	    }
	}

	if (api->gp_setopt_fn){
	    if ((slen = snprintf(NULL, 0, "%s/%s", diskio_dir,
				 DISKIO_WRITEFILE)) <= 0)
		goto done;
	    if ((diskio_writefile = malloc(slen+1)) == NULL)
		goto done;
	    snprintf(diskio_writefile, slen+1, "%s/%s", diskio_dir,
		     DISKIO_WRITEFILE);

	    if ((slen = snprintf(NULL, 0, "%s/%s", diskio_dir,
				 DISKIO_LARGEFILE)) <= 0)
		goto done;
	    if ((diskio_largefile = malloc(slen+1)) == NULL)
		goto done;
	    snprintf(diskio_largefile, slen+1, "%s/%s", diskio_dir,
		     DISKIO_LARGEFILE);
	    if (api->gp_setopt_fn("writefile", diskio_writefile) < 0){
		p->p_disable++;
		clicon_log(LOG_DEBUG, "grideye_agent: Plugin: setopt(writefile):%s",
			   diskio_writefile);
		clicon_log(LOG_NOTICE, "grideye_agent: Plugin: Disabling %s (no writefile)",
			   p->p_name, strerror(errno));
	    }
	    if (api->gp_setopt_fn("largefile", diskio_largefile) < 0){
		p->p_disable++;
		clicon_log(LOG_DEBUG, "grideye_agent: Plugin setopt(largefile):%s",
			   diskio_largefile);
		clicon_log(LOG_NOTICE, "grideye_agent: Plugin: Disabling %s (no largefile)",
			   p->p_name, strerror(errno));
	    }
	    if (api->gp_setopt_fn("device", wi) < 0){
		p->p_disable++;
		clicon_log(LOG_DEBUG, "grideye_agent: Plugin: setopt(device):%s",
			   diskio_largefile);
		clicon_log(LOG_NOTICE, "Plugin: Disabling %s (no device)",
			   p->p_name, strerror(errno));
	    }
	}
    }
    /* Write XML yang metrics tree as JSON */
    if (0)
	fprintf(stderr, "%s %s\n", diskio_largefile, diskio_writefile);
    /* Log file */
    if (filename){
	if ((f = fopen(filename, "w")) == NULL){
	    clicon_err(OE_UNIX, errno, "fopen");
	    exit(0);
	}
    }
    set_signal(SIGINT, grideye_sig, NULL);
    set_signal(SIGTERM, grideye_sig, NULL);

    /* Initialize: create/bind socket for tcp/udp */
    switch (proto){
    case GRIDEYE_PROTO_TCP:
	if ((s = socket(AF_INET, SOCK_STREAM, 0)) < 0) {
	    clicon_err(OE_UNIX, errno, "socket");
	    goto done;
	}
	break;
    case GRIDEYE_PROTO_UDP:
	if ((s = socket(AF_INET, SOCK_DGRAM, 0)) < 0) {
	    clicon_err(OE_UNIX, errno, "socket");
	    goto done;
	}
	if (socket_bind_udp(s,
			    &inaddr,
			    localport,
			    &myaddr) < 0)
	    goto done;
	/* From here on use myaddr, not localport/inaddr */
	clicon_log(LOG_NOTICE, "grideye_agent: Listening to: %s:%hu",
		   inet_ntoa(myaddr.sin_addr), ntohs(myaddr.sin_port));
	/* Local socket */
	if (setsockopt(s, SOL_SOCKET, SO_REUSEADDR, &yes, sizeof(int)) < 0){
	    clicon_err(OE_UNIX, errno, "socket");
	    goto done;
	}
#if defined(SOL_IP)
	if(setsockopt(s, SOL_IP, IP_RECVTTL, &yes, sizeof(int))<0){
	    clicon_err(OE_UNIX, errno, "socket");
	    goto done;
	}
#endif
	break;
    case GRIDEYE_PROTO_HTTP:
    default:
	break;
    }
    /* kickstart */
    switch (proto){
    case GRIDEYE_PROTO_TCP:
    case GRIDEYE_PROTO_UDP:
	if (callhome(s,
		     callhome_url,
		     hostname,
		     userid,
		     proto,
		     &natstate,
		     &myaddr,
		     eid64str,
		     info,
		     curl_timeout,
		     xym) < 0)
	    goto done;
	break;
    case GRIDEYE_PROTO_HTTP:
	if (callhome_url && userid)     /* Timeout Send a (call)home message */
	    if (callhome_http(callhome_url,
			      hostname,
			      userid,
			      proto,
			      NULL,
			      info,
			      curl_timeout,
			      xym,
			      &natstate) < 0)
		goto done;
	if ((xtest = xml_new("new", NULL, NULL)) == NULL)
	    goto done;
	if (natstate == 2)
	    if (http_data(callhome_url,
			  hostname,
			  userid,
			  NULL,
			  &sseq,
			  &ctvalid, &ct0, &ct1,
			  curl_timeout,
			  &natstate,
			  &interval,
			  &xtest) < 0)
		goto done;
	break;
    default:
      break;
    }
    tv.tv_sec = callhome_timeout;
    for (;;){
	FD_ZERO(&fdset);
	tv.tv_usec = 0;
	switch (proto){
	case GRIDEYE_PROTO_UDP:
	    FD_SET(s, &fdset);
	    break;
	case GRIDEYE_PROTO_TCP:
	    if (natstate > 2) /* connected */
		FD_SET(s, &fdset);
	    break;
	case GRIDEYE_PROTO_HTTP:
	    tv.tv_sec = interval/1000;
	    tv.tv_usec = interval%1000;
	default:
	    break;
	}
	//clicon_log(LOG_DEBUG, "Callhome timeout: %d", callhome_timeout;)

	n = select(FD_SETSIZE, &fdset, NULL, NULL, &tv);
	/* Consider timeout to be undefined after select() returns. */
	errno0 = errno;
	t1 = gettimestamp();
	if (n == -1) {
	    clicon_err(OE_UNIX, errno0, "select");
	    goto done;
	}
	/* Timeout */

	/* Check sockets */
	switch(proto){
	case GRIDEYE_PROTO_TCP:
	case GRIDEYE_PROTO_UDP:
	    if (n==0){
		if (callhome(s,
			     callhome_url,
			     hostname,
			     userid,
			     proto,
			     &natstate,
			     &myaddr,
			     eid64str,
			     info,
			     curl_timeout,
			     xym) < 0)
		    goto done;
		tv.tv_sec = callhome_timeout;
	    }
	    if (FD_ISSET(s, &fdset)){  /* udp. can this work for tcp? */
		ok = 0;
		if (echo_packet(s,
				t1,
				buf,
				len,
				eid64str,
				loss,
				reorder,
				duplicate,
				wi,
				plugins,
				hostname,
				&ok) < 0)
		    goto done;
		if (ok)
		    tv.tv_sec = callhome_timeout;
	    }
	    break;
	case GRIDEYE_PROTO_HTTP: /* Eeeh need timer */
	    {
		cbuf *cb;
		if (natstate != 2){

		    interval = 10000;
#ifdef FUZZ
		    if (fuzz)
			interval = 1;
#endif

		    if (callhome_http(callhome_url,
				      hostname,
				      userid,
				      proto,
				      NULL,
				      info,
				      curl_timeout,
				      xym,
				      &natstate) < 0)
			goto done;
		}
		else{
		    if ((cb = cbuf_new()) ==NULL){
			clicon_err(OE_PLUGIN, errno, "cbuf_new");
			goto done;
		    }
		    if ((retval = echo_application_xml(xtest,
						       cb,
						       plugins)) < 0)
			goto done;
		    if (xtest){
			xml_free(xtest);
			xtest = NULL;
		    }
		    if ((xtest = xml_new("new", NULL, NULL)) == NULL)
			goto done;
		    if (http_data(callhome_url,
				  hostname,
				  userid,
				  cb,
				  &sseq,
				  &ctvalid, &ct0, &ct1,
				  curl_timeout,
				  &natstate,
				  &interval,
				  &xtest) < 0)
			goto done;

		    if (cb){
			cbuf_free(cb);
			cb = NULL;
		    }
		}
	    }
	    break;
	default:
	  break;
	}
    } /* for */
    retval = 0;
 done:
    if (xym) /* json yang metric string*/
	xml_free(xym);
    if (xtest)
	xml_free(xtest);
    if (s != -1)
	close(s);
#if 0
    if (callhome_url && name && userid){     /* Timeout Send a (call)home message */
	if (callhome_http(callhome_url, name, userid, proto, localport, info,
			  &natstate, 1) < 0)
	    goto done;
#endif
	if (diskio_writefile)
	    free(diskio_writefile);
	if (diskio_largefile)
	    free(diskio_largefile);
    doexit(0);
    return(retval);
}
